<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/others/fancybox/source/jquery.fancybox.css?v=2.1.5"/>






  <link href="/vendors/googleapis/css/Lato.css" rel="stylesheet" type="text/css">




<link rel="stylesheet" type="text/css" href="/others/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>


    <meta name="description" content="向上，向阳！" />



  <meta name="keywords" content="C,算法,数据结构," />





  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=0.4.5.2" />


<meta name="description" content="code{white-space: pre;}">
<meta name="keywords" content="C,算法,数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面试准备">
<meta property="og:url" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/index.html">
<meta property="og:site_name" content="SmileLingyong">
<meta property="og:description" content="code{white-space: pre;}">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/内存空间大小.png">
<meta property="og:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/数据类型.png">
<meta property="og:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/浮点数在计算机中的存储.png">
<meta property="og:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/内存对齐.jpg">
<meta property="og:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/虚表.png">
<meta property="og:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/associative.png">
<meta property="og:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/进程状态.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6obdia8LMCOcf7jYrqoOicbSibWDHjZ09bN0EvBBTP9mSvpbnJbWyQ7XkA/640?wx_fmt=jpeg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6Dv4ibTib5yHxPK32EQX36oDnA3QslaKm7nbKvnA1CNzMIgo14qbqCwxA/640?wx_fmt=jpeg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6LvLHb8IamLbw9FMpkZCffibFCHDkIXweiaG1kOmTOEPGBeibq57p6vcKg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6ASZ0tUoicFz5DcbtCl3VQsHV1pqibHzofTqNl9X1gyicJ3nML9OibYcOXQ/640?wx_fmt=jpeg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6tqvKuiaicm2VjHZtQ4YECiaqicdDpibTq01TKT7ibZIF1zzE6FCrH7fPKg4Q/640?wx_fmt=jpeg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6iajVzibicHdtnVHC8FEPXFHdFd4mibDoD6sicRRX5bGkFsXe0Onk2tU4KNA/640?wx_fmt=jpeg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6zZEXqxCRlP6a2UicyDcNJ8eea3kcDQiayWbd4ObFoWxWxsyrZwUSzbaQ/640?wx_fmt=jpeg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6ticRkYufWWnNtRmYCMWNLlSqGu7uN7fOPAicVUNPiapQQVX2MgGkf3fpg/640?wx_fmt=jpeg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6ibVY2FYzjDPPUia3fAcwzoZjbtgM8j06GqNDd8Iw6NDqGdTYbOsDBvcg/640?wx_fmt=jpeg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6rRjVuJAgsQibQgnT55AZQXSe6utFsLTeiaRtoMCrBjlq18b43eojrBmA/640?wx_fmt=jpeg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6luAMhnIplsx90WWgCcnn0403kaOJhGEcJqBgHqNtPSEGR1icOicMdavw/640?wx_fmt=jpeg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6nakeMzibswkEQROAIVD9d084aWDnYyPFtfAO31araPMa7JVpiarx507g/640?wx_fmt=jpeg">
<meta property="og:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/copy_01.png">
<meta property="og:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/copy_02.png">
<meta property="og:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/copy_03.png">
<meta property="og:image" content="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/e92d0ebc-7d46-413b-aec1-34a39602f787.png">
<meta property="og:image" content="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg">
<meta property="og:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/撤销修改.png">
<meta property="og:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/git.png">
<meta property="og:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/git_merge.png">
<meta property="og:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/git_rebase.png">
<meta property="og:updated_time" content="2019-09-13T07:43:12.424Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++面试准备">
<meta name="twitter:description" content="code{white-space: pre;}">
<meta name="twitter:image" content="http://yoursite.com/2018/04/07/Interview-preparation-of-cpp/内存空间大小.png">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'always'
  };
</script>



  <title> C++面试准备 | SmileLingyong </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div id="container" class="container one-column page-post-detail">

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  
  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
      
	  	<span style="font-size:14px;float:right;padding:39px 40px 0 0;">——穷则独善其身，达则兼济天下.</span>
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">

        	<div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C++面试准备
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            Posted on
            <time itemprop="dateCreated" datetime="2018-04-07T23:54:00+08:00" content="2018-04-07">
              2018-04-07 23:54
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; In
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
                  , 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
            <span id="/2018/04/07/Interview-preparation-of-cpp/"class="leancloud_visitors"  data-flag-title="C++面试准备">
            &nbsp; | &nbsp;   
            views
            </span>
          
        </div>
      </header>
    


    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <meta name="generator" content="pandoc">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pygments-css@1.0.0/github.min.css" type="text/css">
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<a id="more"></a>
<h3 id="c">C++</h3>
<h4 id="c-数据类型取值范围精度">C 数据类型/取值范围/精度</h4>
<p>计算机的所有指令和数据都保存在计算机的存储部件——<strong>内存</strong>里，内存保存数据速度快，数据可被随机访问，但掉电即失。内存中的存储单元是一个线性的地址表，是按 <strong>字节(Byte)</strong> 进行编址的，即每个字节的存储单元都对应着一个唯一的地址。 在程序设计语言中，通常用字节数来衡量变量或数据类型所占内存空间的大小。</p>
<p>1个字节等于8个二进制位，也称作比特，<code>1 Byte = 8 bit</code>，即可表示的整数范围为0 ～ 255，0 ～ )，bit 是 binary digit 二进制数的缩写。 <strong>位</strong> 是衡量物理存储器容量的最小单位。</p>
<div class="figure">
<img src="/2018/04/07/Interview-preparation-of-cpp/内存空间大小.png">

</div>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>KB = <span class="number">1024</span>byte = <span class="number">2</span>的<span class="number">10</span>次方 byte，转化为<span class="number">16</span>进制为<span class="number">0x400</span>。同时换一种说法，<span class="number">1</span>KB可以表示<span class="number">1024</span>个地址，<span class="number">0x400</span>个地址，而且表示地址的范围是<span class="number">0x00</span>~<span class="number">0x3FF</span>。（记住）</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>KB = <span class="number">2</span>的<span class="number">11</span>次方byte, 转化为<span class="number">16</span>进制为<span class="number">0x800</span>，表示的地址范围为<span class="number">0x00</span>~<span class="number">7</span>FF。其中<span class="number">0x400</span>~<span class="number">0x7FF</span>表示的是第二KB的范围。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>KB = <span class="number">2</span>的<span class="number">12</span>次方byte，<span class="number">0x1000</span>，表示的地址范围<span class="number">0x000</span>~<span class="number">0xFFF</span>。（特殊要记住）</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>MB = <span class="number">1024</span>KB = <span class="number">2</span>的<span class="number">20</span>次方byte，<span class="number">0x100000</span>。表示的地址范围为<span class="number">0x00000</span>~<span class="number">0xFFFFF</span>。（特殊要记住）</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>GB= <span class="number">2</span>的<span class="number">30</span>次方byte，<span class="number">0x40000000</span>。表示的地址范围为<span class="number">0x00000</span>~<span class="number">0x3FFFFFFF</span>。</span><br><span class="line"></span><br><span class="line">那么对于一个任意给定的地址范围（必然是<span class="number">1</span>KB的整数倍）怎么反推字节数呢？</span><br><span class="line">例如,<span class="number">0x000000</span>~<span class="number">0x1FFFFF</span>。</span><br><span class="line">第一种解法，记住<span class="number">1</span>M是<span class="number">5</span>个F，多一位是<span class="number">2</span>倍，所以是<span class="number">2</span>M。</span><br><span class="line">第二种解法,记住FFF是<span class="number">4</span>KB，<span class="number">1</span>FF是<span class="number">512</span>, <span class="number">512</span>X4KB=<span class="number">2048</span>KB也就是<span class="number">2</span>M</span><br><span class="line"><span class="number">20180621</span>： <span class="number">0x3000</span> 表示地址<span class="number">0x0000</span><span class="number">-0x2FFF</span>  <span class="number">12</span>K</span><br></pre></td></tr></table></figure>
<div class="figure">
<img src="/2018/04/07/Interview-preparation-of-cpp/数据类型.png">

</div>
<table>
<thead>
<tr class="header">
<th>Type</th>
<th align="center">Storage size</th>
<th align="center">Value range</th>
<th align="center">Precision</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>char</td>
<td align="center">1 Byte</td>
<td align="center">-128 to 127 or 0 to 255</td>
<td align="center"></td>
</tr>
<tr class="even">
<td>unsigned char</td>
<td align="center">1 Byte</td>
<td align="center">0 to 255</td>
<td align="center"></td>
</tr>
<tr class="odd">
<td>signed char</td>
<td align="center">1 Byte</td>
<td align="center">-128 to 127</td>
<td align="center"></td>
</tr>
<tr class="even">
<td>int</td>
<td align="center">4 Bytes</td>
<td align="center">-2,147,483,648 to 2,147,483,647</td>
<td align="center"></td>
</tr>
<tr class="odd">
<td>unsigned int</td>
<td align="center">4 Bytes</td>
<td align="center">0 to 4,294,967,295</td>
<td align="center"></td>
</tr>
<tr class="even">
<td>short</td>
<td align="center">2 Bytes</td>
<td align="center">-32,768 to 32,767</td>
<td align="center"></td>
</tr>
<tr class="odd">
<td>unsigned short</td>
<td align="center">2 Bytes</td>
<td align="center">0 to 65,535</td>
<td align="center"></td>
</tr>
<tr class="even">
<td>long</td>
<td align="center">4 Bytes</td>
<td align="center">-2,147,483,648 to 2,147,483,647</td>
<td align="center"></td>
</tr>
<tr class="odd">
<td>unsigned long</td>
<td align="center">4 Bytes</td>
<td align="center">0 to 4,294,967,295</td>
<td align="center"></td>
</tr>
<tr class="even">
<td>float</td>
<td align="center">4 Bytes</td>
<td align="center">1.2E-38 to 3.4E+38</td>
<td align="center">6 decimal places</td>
</tr>
<tr class="odd">
<td>double</td>
<td align="center">8 Bytes</td>
<td align="center">2.3E-308 to 1.7E+308</td>
<td align="center">15 decimal places</td>
</tr>
<tr class="even">
<td>long double</td>
<td align="center">10</td>
<td align="center">3.4E-4932 to 1.1E+4932</td>
<td align="center">19 decimal places</td>
</tr>
</tbody>
</table>
<hr>
<blockquote>
<p><strong><code>char</code></strong></p>
</blockquote>
<p>char 占 1 个字节 Byte，即 8 个bit。能表示的范围在 [<span class="math inline">\(0​\)</span> ～ <span class="math inline">\(2^8-1​\)</span>]，即 0 ～ 255，</p>
<blockquote>
<p><strong><code>int</code></strong></p>
</blockquote>
<p>默认的int为有符号整型，占 4 个字节 Byte，即 4x8=32 个bit。能表示的整数范围在 [<span class="math inline">\(-2^{31}\)</span> ～ <span class="math inline">\(2^{31}-1\)</span>]，即 -2,147,483,648 ～ 2,147,483,647</p>
<blockquote>
<p><strong><code>unsigned int</code></strong></p>
</blockquote>
<p>无符号整型，占 4 个字节，32位，能表示整数范围在 [<span class="math inline">\(0\)</span> ～ <span class="math inline">\(2^{32}-1\)</span>]，即 0 ～ 4,294,967,295</p>
<blockquote>
<p><strong><code>float</code> 和 <code>double</code></strong></p>
</blockquote>
<p>通常，<strong>浮点数</strong>是将实数分为阶码和尾数两部分来表示。例如，实数 <span class="math inline">\(N\)</span> 可以表示为：<br>
<span class="math display">\[
N = S * r^j
\]</span></p>
<ul>
<li><span class="math inline">\(S\)</span> 为尾数(正负均可)，一般规定用纯小数形式：<strong>实数的小数部分</strong></li>
<li><span class="math inline">\(j\)</span> 为阶码(正负均可，但必须是整数)：<strong>实数的指数部分</strong></li>
<li><span class="math inline">\(r\)</span> 是基数，对于二进制而言 <span class="math inline">\(r = 2\)</span> ，即 <span class="math inline">\(N = S * 2^j\)</span> 。例如：10.0111 = 0.100111 x <span class="math inline">\(2^{10}\)</span></li>
</ul>
<p>浮点数再计算机中的存储格式如下图：</p>
<div class="figure">
<img src="/2018/04/07/Interview-preparation-of-cpp/浮点数在计算机中的存储.png">

</div>
<p><u>阶码</u>所占的位数决定实数的<strong>表示范围</strong>；<u>尾数</u>所占的位数决定实数的<strong>精度</strong>，<u>尾数的符号</u>决定实数的<strong>正负</strong>。</p>
<blockquote>
<p><strong>取值范围</strong></p>
</blockquote>
<p>float 和 double 的<strong>范围</strong>是由<strong>指数的位数来决定</strong>的。float的指数位有8位，而double的指数位有11位，分布如下：</p>
<ul>
<li>float: <code>1bit（符号位）+  8bits （指数位）+ 23bits（尾数位）</code></li>
<li>double: <code>1bit（符号位）+  11bits（指数位）+ 52bits（尾数位）</code></li>
</ul>
<p>于是，float 的指数范围为 -127~128，而 double 的指数范围为 -1023~1024，并且指数位是按补码的形式来划分的。其中负指数决定了浮点数所能表达的绝对值最小的数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。</p>
<ul>
<li>float的范围为: <span class="math inline">\(-2^{128}\)</span> ～ <span class="math inline">\(+2^{128}\)</span> ， 即 -3.40E+38 ~ +3.40E+38</li>
<li>double的范围为: <span class="math inline">\(-2^{1024}\)</span> ～ <span class="math inline">\(+2^{1024}\)</span>，即-1.79E+308 ~ +1.79E+308</li>
</ul>
<blockquote>
<p><strong>精度</strong></p>
</blockquote>
<p>float 和 double 的<strong>精度</strong>是由<strong>尾数的位数来决定</strong>的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。</p>
<ul>
<li>float：<span class="math inline">\(2^{23}\)</span> = 8388608，共七位，意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字</li>
<li>double：<span class="math inline">\(2^{52}\)</span> = 4503599627370496，一共16位，同理，double的精度为15~16位。</li>
</ul>
<hr>
<h4 id="c中的基本数据类型及派生类型">C++中的基本数据类型及派生类型</h4>
<p>1）整型 int</p>
<p>2）浮点型 单精度float，双精度double</p>
<p>3）字符型 char</p>
<p>4）逻辑型 bool</p>
<p>5）控制型 void</p>
<p>基本类型的字长及其取值范围可以放大和缩小，改变后的类型就叫做基本类型的派生类型。派生类型声明符由基本类型关键字char、int、float、double前面加上类型修饰符组成。</p>
<p>类型修饰符包括：</p>
<p>&gt;short 短类型，缩短字长</p>
<p>&gt;long 长类型，加长字长</p>
<p>&gt;signed 有符号类型，取值范围包括正负值</p>
<p>&gt;unsigned 无符号类型，取值范围只包括正值</p>
<hr>
<h4 id="typdef-和-define区别">typdef 和 define区别</h4>
<p>#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查</p>
<p>typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名</p>
<p>typedef (int*) pINT;</p>
<p>#define pINT2 int*</p>
<p>效果相同？实则不同！实践中见差别：pINT a,b;的效果同int <em>a; int </em>b;表示定义了两个整型指针变量。而pINT2 a,b;的效果同int *a, b;表示定义了一个整型指针变量a和整型变量b。</p>
<h4 id="define-和-const-的区别">define 和 const 的区别</h4>
<ul>
<li>#define定义的常量没有类型，所给出的是一个立即数；const定义的常量有类型名字，存放在静态区域</li>
<li>处理阶段不同，#define定义的宏变量在预处理时进行替换，可能有多个拷贝，const所定义的变量在编译时确定其值，只有一个拷贝。</li>
<li>#define定义的常量是不可以用指针去指向，const定义的常量可以用指针去指向该常量的地址</li>
<li>#define可以定义简单的函数，const不可以定义函数</li>
</ul>
<h4 id="const-作用">const 作用</h4>
<ul>
<li>修饰变量，说明该变量不可以被改变</li>
<li>修饰指针，分为指向常量的指针和指针常量</li>
<li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() : a(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 常指针</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 常引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 常指针，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 常指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure>
<h4 id="static">static</h4>
<ul>
<li>函数体内： static 修饰的局部变量作用范围为该函数体，不同于auto变量，其内存只被分配一次，因此其值在下次调用的时候维持了上次的值</li>
<li>模块内：static修饰全局变量或全局函数，可以被模块内的所有函数访问，但是不能被模块外的其他函数访问，使用范围限制在声明它的模块内</li>
<li>类中：修饰成员变量，表示该变量属于整个类所有，对类的所有对象只有一份拷贝</li>
<li>类中：修饰成员函数，表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量</li>
</ul>
<blockquote>
<p>注意和const的区别！！！const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象</p>
</blockquote>
<h4 id="this-指针">this 指针</h4>
<ol style="list-style-type: decimal">
<li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code>成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用this指针：</li>
</ol>
<ul>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ul>
<h4 id="inline-内联函数">inline 内联函数</h4>
<ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> A::doA() &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure>
<p><strong>编译器对 inline 函数的处理步骤</strong></p>
<ul>
<li>将 inline 函数体复制到 inline 函数调用点处；</li>
<li>为所用 inline 函数中的局部变量分配内存空间；</li>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>
</ul>
<p><strong>优缺点</strong></p>
<p><strong>1. 优点</strong></p>
<ul>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ul>
<p><strong>2. 缺点</strong></p>
<ul>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ul>
<h4 id="虚函数virtual可以是内联函数inline吗">虚函数（virtual）可以是内联函数（inline）吗？</h4>
<ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译器 建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
<h4 id="volatile">volatile</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>volatile 关键字是一种类型修饰符，volatile是“易变的”、“不稳定”的意思。它用来解决变量在“共享”环境下容易出现读取错误的问题。变量如果加了volatile修饰，则会从内存中重新装载内容，而不是直接从寄存器中拷贝内容，即告诉编译器不应对这样的对象进行优化。</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（可以暂时先不看）</span><br><span class="line">在本次线程内，当读取一个变量时，为了提高读取速度，编译器进行优化时有时会先把变量读取到一个寄存器中；以后，再读取变量值时，就直接从寄存器中读取；当变量值在本线程里改变时，会同时把变量的新值copy到该寄存器中，以保持一致。当变量因别的线程值发生改变，上面寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致。</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>可以避免优化、强制内存读取的顺序，但是<span class="keyword">volatile</span>并没有线程同步的语义，C++标准并不能保证它在多线程情况的正确性。C++<span class="number">11</span>开始有一个很好用的库，那就是<span class="keyword">atomic</span>类模板，在&lt;<span class="keyword">atomic</span>&gt;头文件中，多个线程对<span class="keyword">atomic</span>对象进行访问是安全的，并且提供不同种类的线程同步。它默认使用的是最强的同步，所以我们就使用默认的就好。</span><br></pre></td></tr></table></figure>
<h4 id="explicit">explicit</h4>
<p>explicit用来防止由构造函数定义的隐式转换。</p>
<ul>
<li>隐式转换：可以用单个实参来调用的构造函数定义了从形参类型到该类类型的一个隐式转换。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">things</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        things(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;name =<span class="string">""</span>):</span><br><span class="line">              m_name(name),height(<span class="number">0</span>),weight(<span class="number">10</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">CompareTo</span><span class="params">(<span class="keyword">const</span> things &amp; other)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里things的构造函数可以只用一个实参完成初始化。所以可以进行一个隐式转换，像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">things a;</span><br><span class="line">................<span class="comment">//在这里被初始化并使用。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> nm =<span class="string">"book_1"</span>;</span><br><span class="line"><span class="comment">//由于可以隐式转换，所以可以下面这样使用</span></span><br><span class="line"><span class="keyword">int</span> result = a.CompareTo(nm);</span><br></pre></td></tr></table></figure>
<p>这段程序使用一个string类型对象作为实参传给things的CompareTo函数。这个函数本来是需要一个tings对象作为实参。现在编译器使用string nm来构造并初始化一个things对象，新生成的临时的things对象被传递给CompareTo函数，并在离开这段函数后被析构。</p>
<ul>
<li>正确使用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">things</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        explicit things(const std::string&amp;name =""):</span><br><span class="line">              m_name(name),height(<span class="number">0</span>),weight(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">CompareTo</span><span class="params">(<span class="keyword">const</span> things &amp; other)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时你仍然可以通过显式使用构造函数完成上面的类型转换：</span></span><br><span class="line">things a;</span><br><span class="line">................<span class="comment">//在这里被初始化并使用。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> nm =<span class="string">"book_1"</span>;</span><br><span class="line"><span class="comment">//显示使用构造函数</span></span><br><span class="line"><span class="keyword">int</span> result = a.CompareTo(things(nm));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.cnblogs.com/winnersun/archive/2011/07/16/2108440.html" target="_blank" rel="noopener">1</a></p>
</blockquote>
<h4 id="auto-和-decltype">auto 和 decltype</h4>
<ul>
<li><p>auto类型说明符：让编译器通过初始值来推算变量的类型，auto定义的变量必须有初始值。</p></li>
<li><p>decltype 类型指示符：从表达式的类型推断出要定义的变量的类型</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>  			<span class="comment">// i 为 int类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(f()) sum = x 	<span class="comment">// sum的类型，是函数f()的返回值类型</span></span><br></pre></td></tr></table></figure>
<h4 id="assert">assert()</h4>
<p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p>
<p>assert() 使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">assert( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure>
<h4 id="sizeof">sizeof()</h4>
<p>sizeof()是操作符，而非函数。</p>
<ul>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">"abcdef"</span>;	</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(a) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 6 统计数组长度，不包括\0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 7 统计数组长度，包括\0，到第一个\0就结束</span></span><br></pre></td></tr></table></figure>
<h4 id="pragma-packn">#pragma pack(n)</h4>
<p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p>
<p>#pragma pack(n) 使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">double</span> m4;</span><br><span class="line">    <span class="keyword">int</span> m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)   <span class="comment">// 恢复对齐状态</span></span></span><br></pre></td></tr></table></figure>
<h4 id="位域">位域</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bit mode: <span class="number">2</span>;    <span class="comment">// mode 占 2 位</span></span><br></pre></td></tr></table></figure>
<p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p>
<ul>
<li>位域在内存中的布局是与机器有关的</li>
<li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li>
<li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li>
</ul>
<h4 id="extern-c">extern “C”</h4>
<ul>
<li>被 extern 限定的函数或变量是 extern 类型的</li>
<li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li>
</ul>
<p>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。</p>
<p><strong>extern “C” 使用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="c-中-struct-和-class">C++ 中 struct 和 class</h4>
<p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p>
<p><strong>区别</strong></p>
<p>最本质的一个区别就是默认的访问控制</p>
<ul>
<li>默认的继承访问权限。struct 是 public 的，class 是 private 的。</li>
<li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li>
</ul>
<h4 id="结构体-struct-和-共同体-union联合的区别">结构体 struct 和 共同体 union（联合）的区别</h4>
<p><strong>结构体</strong>：将不同类型的数据组合成一个整体，是自定义类型。</p>
<p><strong>共同体</strong>：不同类型的几个变量共同占用一段内存</p>
<p>1）结构体中的每个成员都有自己独立的地址，它们是同时存在的；</p>
<p>​ 共同体中的所有成员占用同一段内存，它们不能同时存在。</p>
<p>2）sizeof(struct)是内存对齐后所有成员长度的总和，sizeof(union)是内存对齐后最长数据成员的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">union</span> Data</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">float</span> f;</span><br><span class="line">   <span class="keyword">char</span>  str[<span class="number">20</span>];	</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">union</span> Data data;        </span><br><span class="line"> </span><br><span class="line">   data.i = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"data.i : %d\n"</span>, data.i);</span><br><span class="line">   </span><br><span class="line">   data.f = <span class="number">220.5</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"data.f : %f\n"</span>, data.f);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">strcpy</span>( data.str, <span class="string">"C Programming"</span>);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"data.str : %s\n"</span>, data.str);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有的成员都能完好输出，因为同一时间只用到一个成员。</span></span><br><span class="line"><span class="comment">data.i : 10</span></span><br><span class="line"><span class="comment">data.f : 220.500000</span></span><br><span class="line"><span class="comment">data.str : C Programming</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="结构体为什么要内存对齐呢">结构体为什么要内存对齐呢？</h4>
<p>1 . <strong>平台原因（移植原因）</strong>：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。内存对齐，是为了让内存存取更有效率而采用的一种编译阶段优化内存存取的手段。</p>
<p>2 . <strong>硬件原因</strong>：经过内存对齐之后，CPU的内存访问速度大大提升。</p>
<p><strong>内存对齐规则</strong></p>
<ol style="list-style-type: decimal">
<li>内存对齐是指首地址对齐，而不是说每个变量大小对齐</li>
<li>结构体内存对齐要求结构体内每一个成员变量都是内存对齐的</li>
<li>结构体第一个成员的 <strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 offset 都是<strong>该成员大小 与 有效对齐值 中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</li>
<li><strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;x1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;x2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2; </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">&#125;x3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(x1));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(x2));  <span class="comment">// 输出12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(x3));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上测试都是再Linux环境下进行，linux下默认#pragma pack(4)，且结构体中最长的数据类型为4个字节，所以有效对齐单位为4字节，下面根据上面所说的规则以 x2 来分析其内存布局：<br>
首先使用规则1，对成员变量进行对齐：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(c1) = <span class="number">1</span> &lt;= <span class="number">4</span>(有效对齐位)，按照<span class="number">1</span>字节对齐，占用第<span class="number">0</span>单元；</span><br><span class="line"><span class="keyword">sizeof</span>(i) = <span class="number">4</span> &lt;= <span class="number">4</span>(有效对齐位)，相对于结构体首地址的偏移要为<span class="number">4</span>的倍数，占用第<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">7</span>单元；</span><br><span class="line"><span class="keyword">sizeof</span>(c2) = <span class="number">1</span> &lt;= <span class="number">4</span>(有效对齐位)，相对于结构体首地址的偏移要为<span class="number">1</span>的倍数，占用第<span class="number">8</span>单元；</span><br></pre></td></tr></table></figure>
<p>然后使用规则2，对结构体整体进行对齐：</p>
<p>x2 中变量 i 占用内存最大占4字节，而有效对齐单位也为4字节，两者较小值就是4字节。因此整体也是按照4字节对齐。由规则1得到 x2 占9个字节，此处再按照规则2进行整体的4字节对齐，所以整个结构体占用12个字节。</p>
<p>根据上面的分析，不难得出上面例子三个结构体的内存布局如下：</p>
<div class="figure">
<img src="/2018/04/07/Interview-preparation-of-cpp/内存对齐.jpg">

</div>
<h4 id="定义和声明的区别">定义和声明的区别</h4>
<ul>
<li>声明是告诉编译器变量的类型和名字，不会为变量分配空间</li>
<li>定义需要分配空间，同一个变量可以被声明多次，但是只能被定义一次</li>
</ul>
<h4 id="c和c的区别">C和C++的区别</h4>
<p>（1）C是面向过程的语言，是一个结构化的语言，考虑如何通过一个过程对输入进行处理得到输出；C++是面向对象的语言，主要特征是“封装、继承和多态”。封装隐藏了实现细节，使得代码模块化；派生类可以继承父类的数据和方法，扩展了已经存在的模块，实现了代码重用；多态则是“一个接口，多种实现”，通过派生类重写父类的虚函数，实现了接口的重用。<br>
（2）C和C++动态管理内存的方法不一样，C是使用malloc/free，而C++除此之外还有new/delete关键字。<br>
（3）C++支持函数重载，C不支持函数重载<br>
（4）C++中有引用，C中不存在引用的概念</p>
<h4 id="c中指针和引用的区别">C++中指针和引用的区别</h4>
<p>1）指针是一个新的变量，存储了另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；<br>
引用只是一个别名，还是变量本身，对引用的任何操作就是对变量本身进行操作，以达到修改变量的目的<br>
2）引用只有一级，而指针可以有多级<br>
3）指针传参的时候，还是值传递，指针本身的值不可以修改，需要通过解引用才能对指向的对象进行操作。引用传参的时候，传进来的就是变量本身，因此变量可以被修改</p>
<h4 id="引用作为函数参数以及返回值的好处">引用作为函数参数以及返回值的好处</h4>
<p>对比值传递，引用传参的好处：</p>
<p>1）在函数内部可以对此参数进行修改</p>
<p>2）提高函数调用和运行的效率（所以没有了传值和生成副本的时间和空间消耗）</p>
<p>如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p>
<p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。</p>
<p>但是有以下的限制：</p>
<p>1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</p>
<p>2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</p>
<p>3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。</p>
<h4 id="左值引用">左值引用</h4>
<p>常规引用，一般表示对象的身份。</p>
<h4 id="右值引用">右值引用</h4>
<p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p>
<p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p>
<ul>
<li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li>
<li>能够更简洁明确地定义泛型函数。</li>
</ul>
<h4 id="引用折叠">引用折叠</h4>
<ul>
<li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li>
<li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li>
</ul>
<h4 id="范围解析运算符">：：范围解析运算符</h4>
<ol style="list-style-type: decimal">
<li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ol>
<p><strong>:: 使用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;        <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count; <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::count = <span class="number">1</span>;      <span class="comment">// 设置全局的 count 的值为 1</span></span><br><span class="line"></span><br><span class="line">    A::count = <span class="number">2</span>;     <span class="comment">// 设置类 A 的 count 为 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">// 局部的 count</span></span><br><span class="line">    count = <span class="number">3</span>;        <span class="comment">// 设置局部的 count 的值为 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section">———-</h4>
<hr>
<h4 id="继承中的特点">继承中的特点</h4>
<p>有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。</p>
<ul>
<li>1.<strong>public 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</li>
<li>2.<strong>protected 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</li>
<li>3.<strong>private 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</li>
</ul>
<p>但无论哪种继承方式，上面两点都没有改变：</p>
<ul>
<li>1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；</li>
<li>2.protected 成员可以被派生类访问。</li>
</ul>
<h4 id="重载overload覆盖重写override隐藏重定义overwrite这三者之间的区别">重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别</h4>
<p>1）overload，函数名相同，参数列表（参数的类型，个数，顺序不同）不同，这就是函数重载，返回值类型可以不同。<br>
特征：相同范围（同一个类中）、函数名字相同、参数不同、virtual关键字可有可无<br>
2）override，派生类覆盖基类的虚函数，实现接口的重用，返回值类型必须相同<br>
特征：不同范围（基类和派生类）、函数名字相同、参数相同、基类中必须有virtual关键字（必须是虚函数）<br>
3）overwrite，派生类屏蔽了其同名的基类函数，返回值类型可以不同<br>
特征：不同范围（基类和派生类）、函数名字相同、参数不同或者参数相同且无virtual关键字</p>
<h4 id="多态-虚函数-纯虚函数">**多态， 虚函数， 纯虚函数</h4>
<p><strong>多态</strong>：不同对象接收相同的消息产生不同的动作。多态包括 <u>编译时多态</u> 和 <u>运行时多态</u></p>
<ul>
<li><strong>运行时多态</strong>：通过继承和虚函数来体现的。</li>
<li><strong>编译时多态</strong>：运算符重载上。</li>
</ul>
<p>封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。多态也有代码重用的功能，还有解决项目中紧耦合的问题，提高程序的可扩展性。<br>
C++实现多态的机制很简单，在继承体系下，将父类的某个函数给成虚函数（即加上virtual关键字），在派生类中对这个虚函数进行重写，利用父类的指针或引用调用虚函数。通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。对于虚函数调用来说，每一个对象内部都有一个虚表指针，在构造子类对象时，执行构造函数中进行虚表的创建和虚表指针的初始化，该虚表指针被初始化为本类的虚表。所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。</p>
<p>需要注意的几点总结（基类有虚函数）：<br>
1、每一个类都有虚表，单继承的子类拥有一张虚表，子类对象拥有一个虚表指针；若子类是多重继承（同时继承多个基类），则子类维护多张虚函数表（针对不同基类构建不同虚表），该子类的对象也将包含多个虚表指针。</p>
<p>2、虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现。如果基类3个虚函数，那么基类的虚表中就有三项（虚函数地址），派生类也会有虚表，至少有三项，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现。如果派生类有自己的虚函数，那么虚表中就会添加该项。</p>
<p>3、派生类的虚表中虚函数地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。</p>
<div class="figure">
<img src="/2018/04/07/Interview-preparation-of-cpp/虚表.png">

</div>
<p>第一：编译器在发现Father 类中有虚函数时，会自动为每个含有虚函数的类生成一份虚函数表，也叫做虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址。</p>
<p>第二：编译器会在每个对象的前四个字节中保存一个虚表指针，即（vptr),指向对象所属类的虚表。在程序运行时的合适时机，根据对象的类型去初始化vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数。</p>
<p>第三：所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表。</p>
<h4 id="虚函数-与-纯虚函数">虚函数 与 纯虚函数</h4>
<p><strong>虚函数</strong>： 在基类中用virtual的成员函数。允许在派生类中对基类的虚函数重新定义。<br>
基类的虚函数可以有函数体，基类也可以实例化。<br>
虚函数要有函数体，否则编译过不去。<br>
虚函数在子类中可以不覆盖。<br>
构造函数不能是虚函数。</p>
<p><strong>纯虚函数</strong>：纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承。包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象。</p>
<p>纯虚函数后面有 = 0；<br>
抽象类不可以实例化。但可以定义指针。<br>
如果派生类如果不是先基类的纯虚函数，则仍然是抽象类。<br>
抽象类可以包含虚函数。</p>
<blockquote>
<p>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</p>
</blockquote>
<h4 id="虚函数是怎么实现的">虚函数是怎么实现的</h4>
<p>每一个含有虚函数的类都至少有有一个与之对应的虚函数表，其中存放着该类所有虚函数对应的函数指针（地址）</p>
<p>类的示例对象不包含虚函数表，只有虚指针</p>
<p>派生类会生成一个兼容基类的虚函数表。</p>
<h4 id="构造函数为什么一般不定义为虚函数而析构函数一般写成虚函数的原因">构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？</h4>
<p><strong>1、构造函数不能声明为虚函数</strong></p>
<ul>
<li>因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等</li>
<li>虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数及构造函数了</li>
</ul>
<p><strong>2、析构函数最好声明为虚函数</strong></p>
<ul>
<li>首先析构函数可以为虚函数，当析构一个指向派生类的基类指针时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。</li>
<li>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。</li>
</ul>
<h4 id="构造函数中是否可以调用虚函数">构造函数中是否可以调用虚函数</h4>
<p>１.　从语法上讲，调用完全没有问题。</p>
<p>２.　但是从效果上看，往往不能达到需要的目的。</p>
<p>Effective 的解释是：</p>
<p>派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。</p>
<p>同样，进入基类析构函数时，对象也是基类类型。</p>
<p>所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。</p>
<ul>
<li>在构造函数中调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base()</span><br><span class="line">    &#123;</span><br><span class="line">       Fuction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::Fuction"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">      Fuction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::Fuction"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样定义一个A的对象，会输出什么？</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出： </span></span><br><span class="line"><span class="comment">Base::Fuction </span></span><br><span class="line"><span class="comment">A::Fuction</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在析构函数中调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"in A"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~A()&#123;show();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"in B"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出： </span></span><br><span class="line"><span class="comment">in A </span></span><br><span class="line"><span class="comment">in A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="虚函数指针虚函数表">虚函数指针、虚函数表</h4>
<ul>
<li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li>
<li>虚函数表：在程序只读数据段（<code>.rodata section</code>，见：<a href="https://github.com/huihut/interview#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li>
</ul>
<h4 id="继承中子类构造函数和析构函数调用顺序">继承中，子类构造函数和析构函数调用顺序</h4>
<h4 id="子类析构时要调用父类的析构函数吗">子类析构时，要调用父类的析构函数吗？</h4>
<p>构造函数：先调用父类构造函数，然后调用子类。</p>
<p>析构函数：先调用子类析构，然后调用父类。</p>
<p>并且析构函数要是virtual的，否则如果用父类的指针指向子类对象的时候，析构函数静态绑定，不会调用子类的析构。</p>
<p>不用显式调用，会自动调用</p>
<h4 id="虚继承">虚继承</h4>
<p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p>
<p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
<h4 id="虚继承-与-虚函数的联系与区别">虚继承 与 虚函数的联系与区别</h4>
<ul>
<li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li>
<li>不同之处：</li>
<li>虚继承
<ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移</li>
</ul></li>
<li>虚函数
<ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul></li>
</ul>
<h4 id="模板类成员模板虚函数">模板类、成员模板、虚函数</h4>
<ul>
<li>模板类中可以使用虚函数</li>
<li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li>
</ul>
<h4 id="抽象类接口类聚合类">抽象类、接口类、聚合类</h4>
<ul>
<li>抽象类：含有纯虚函数的类</li>
<li>接口类：仅含有纯虚函数的抽象类</li>
<li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：</li>
<li>所有成员都是 public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有 virtual 函数</li>
</ul>
<h4 id="friend-友元类和友元函数">friend 友元类和友元函数</h4>
<ul>
<li>能访问私有成员</li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ul>
<h4 id="友元函数和友元类">友元函数和友元类</h4>
<p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。</p>
<p>通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。</p>
<p>友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</p>
<p>1）友元函数</p>
<p>友元函数是可以访问类的私有成员的非成员函数。它是定义在类外的普通函数，不属于任何类，但是需要在类的定义中加以声明。</p>
<blockquote>
<p><strong>friend 类型 函数名(形式参数);</strong></p>
</blockquote>
<p>一个函数可以是多个类的友元函数，只需要在各个类中分别声明。</p>
<p>2）友元类</p>
<p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。</p>
<blockquote>
<p><strong>friend class 类名;</strong></p>
</blockquote>
<p>使用友元类时注意：</p>
<ol style="list-style-type: decimal">
<li><p>友元关系不能被继承。</p></li>
<li><p>友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</p></li>
<li><p>友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p></li>
</ol>
<h4 id="c的内存管理">**C++的内存管理</h4>
<p>在C++中，内存被分成五个区：栈、堆、自由存储区、静态存储区、常量区</p>
<ul>
<li><strong>栈</strong>：存放函数的参数和局部变量，编译器自动分配和释放</li>
<li><strong>堆</strong>：new关键字动态分配的内存，由程序员手动进行释放，否则程序结束后，由操作系统自动进行回收</li>
<li><strong>自由存储区</strong>：由malloc分配的内存，和堆十分相似，由对应的free进行释放</li>
<li><strong>全局/静态存储区</strong>：存放全局变量和静态变量</li>
<li><strong>常量区</strong>：存放常量，不允许被修改</li>
</ul>
<h4 id="栈和堆的区别">栈和堆的区别</h4>
<table>
<colgroup>
<col width="7%">
<col width="46%">
<col width="46%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>堆</th>
<th>栈</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>管理方式</td>
<td>堆中资源由程序员控制（容易产生memory leak）</td>
<td>栈资源由编译器自动管理，无需手工控制</td>
</tr>
<tr class="even">
<td>内存管理机制</td>
<td>系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存 空间，另外系统会将多余的部分重新放入空闲链表中）</td>
<td>只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了）</td>
</tr>
<tr class="odd">
<td>空间大小</td>
<td>堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大</td>
<td>栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置）。</td>
</tr>
<tr class="even">
<td>碎片问题</td>
<td>对于堆，频繁的new/delete会造成大量碎片，使程序效率降低</td>
<td>对于栈，它是一个先进后出的队列，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别）</td>
</tr>
<tr class="odd">
<td>生长方向</td>
<td>堆向上，向高地址方向增长。</td>
<td>栈向下，向低地址方向增长。</td>
</tr>
<tr class="even">
<td>分配方式</td>
<td>堆都是动态分配（没有静态分配的堆）</td>
<td>栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数 分 配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</td>
</tr>
<tr class="odd">
<td>分配效率</td>
<td>堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。</td>
<td>栈是极其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存 器存放栈地址，栈操作有专门指令。</td>
</tr>
</tbody>
</table>
<h4 id="c中内存泄漏的几种情况">C++中内存泄漏的几种情况</h4>
<p>内存泄漏是指己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<ul>
<li><p>类的构造函数和析构函数中new和delete没有配套</p></li>
<li>在释放对象数组时没有使用delete[]，使用了delete</li>
<li>没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</li>
<li><p>没有正确的清楚嵌套的对象指针</p></li>
</ul>
<h4 id="栈溢出的原因以及解决方法">栈溢出的原因以及解决方法</h4>
<p>栈溢出是指函数中的局部变量造成的溢出（注：函数中形参和函数中的局部变量存放在栈上）</p>
<p>栈的大小通常是1M-2M，所以栈溢出包含两种情况，一是分配的的大小超过栈的最大值，二是分配的大小没有超过最大值，但是接收的buf比原buf小。</p>
<p>1）函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈</p>
<p>2）局部变量体积太大。</p>
<p><strong>解决办法大致说来也有两种：</strong></p>
<p>1&gt; 增加栈内存的数目；如果是不超过栈大小但是分配值小的，就增大分配的大小</p>
<p>2&gt; 使用堆内存；具体实现由很多种方法可以直接把数组定义改成指针,然后动态申请内存;也可以把局部变量变成全局变量，一个偷懒的办法是直接在定义前边加个static，呵呵，直接变成静态变量(实质就是全局变量)</p>
<h4 id="什么是野指针">什么是野指针</h4>
<p>野指针不是NULL指针，是未初始化或者未清零的指针，它指向的内存地址不是程序员所期望的，可能指向了受限的内存。</p>
<p>成因：</p>
<ul>
<li>指针变量没有被初始化</li>
<li>指针指向的内存被释放了，但是指针没有置NULL</li>
<li>指针超过了变量了的作用范围，比如b[10]，指针b+11</li>
</ul>
<h4 id="newdeletemallocfree之间的关系">new、delete、malloc、free之间的关系</h4>
<p>new/delete，malloc/free都是动态分配内存的方式</p>
<ul>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数</li>
</ul>
<h4 id="既然有了mallocfreec中为什么还需要newdelete呢">既然有了malloc/free，C++中为什么还需要new/delete呢？</h4>
<p>（1）<strong>库函数</strong>是依赖于库的，一定程度上独立于语言的。编译器不关心库函数的作用，只保证编译，调用函数参数和返回值符合语法，生成call函数的代码。<br>
（2）<strong>运算符</strong>是语言自身的特性，有固定的语义，编译器知道意味着什么，由编译器解释语义，生成相应的代码。</p>
<p>malloc/free是库函数，new/delete是C++运算符。对于非内部数据类型而言，光用malloc/free无法满足动态对象的要求。new/delete是运算符，编译器保证调用构造和析构函数对对象进行初始化/析构。但是库函数malloc/free是库函数，不会执行构造/析构。</p>
<h4 id="delete和delete的区别">delete和delete[]的区别</h4>
<p>delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数<br>
用new分配的内存用delete释放，用new[]分配的内存用delete[]释放</p>
<h4 id="delete-this-合法吗">delete this 合法吗？</h4>
<p>合法，但：</p>
<ol style="list-style-type: decimal">
<li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 <code>delete this</code>后面没有调用 this 了</li>
<li>必须保证 <code>delete this</code> 后没有人使用了</li>
</ol>
<h4 id="section-1">——</h4>
<h4 id="stl库用过吗常见的stl容器有哪些算法用过几个">STL库用过吗？常见的STL容器有哪些？算法用过几个？</h4>
<p>STL包括两部分内容：<strong>容器</strong> 和 <strong>算法</strong></p>
<p><strong>1. 容器</strong>即存放数据的地方，比如 array, vector，分为两类，<strong>序列式容器</strong> 和<strong>关联式容</strong></p>
<ul>
<li>序列式容器，其中的元素不一定有序，但是都可以被排序，比如vector,list,queue,stack，heap, priority-queue, slist</li>
<li>关联式容器，内部结构是一个平衡二叉树，每个元素都有一个键值和一个实值，比如map, set, hashtable, hash_set</li>
</ul>
<p><strong>2. 算法</strong> 有排序，复制等，以及各个容器特定的算法</p>
<p><strong>3. 迭代器</strong> 是STL的精髓，迭代器提供了一种方法，使得它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构，它将容器和算法分开，让二者独立设计。</p>
<h4 id="vector-实现机制">vector 实现机制</h4>
<h4 id="c中vector和list的区别">C++中vector和list的区别</h4>
<p><strong>vector</strong>和<u>数组类似</u>，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</p>
<p><strong>list</strong> 是<u>由双向链表实现的</u>，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。</p>
<p><strong>vector</strong> 拥有一段连续的内存空间，能很好的支持随机存取，因此vector<int>::iterator支持“+”，“+=”，“&lt;”等操作符。</int></p>
<p><strong>list</strong> 的内存空间可以是不连续，它不支持随机访问，因此list<int>::iterator则不支持“+”、“+=”、“&lt;”等</int></p>
<p>vector<int>::iterator和list<int>::iterator都重载了“++”运算符。</int></int></p>
<p>总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;</p>
<p>如果需要大量的插入和删除，而不关心随机存取，则应使用list。</p>
<h4 id="c常见容器的时间复杂度">C++常见容器的时间复杂度</h4>
<p><code>map</code> ，<code>set</code>，<code>multimap</code>，<code>multiset</code> ：这4种容器是采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:</p>
<ul>
<li>插入：<span class="math inline">\(O(logN)\)</span></li>
<li>查找：<span class="math inline">\(O(logN)\)</span></li>
<li>删除：<span class="math inline">\(O(logN)\)</span></li>
</ul>
<p><code>hash_map</code>，<code>hash_set</code>，<code>hash_multimap</code>，<code>hash_multiset</code>：这4种容器采用哈希表实现。</p>
<ul>
<li>插入：O(1)，最坏情况 O(N)</li>
<li>查找：O(1)，最坏情况 O(N)</li>
<li>删除：O(1)，最坏情况 O(N)</li>
</ul>
<p><strong>标准库提供的8个关联容器</strong></p>
<div class="figure">
<img src="/2018/04/07/Interview-preparation-of-cpp/associative.png">

</div>
<h4 id="map-和-set-的原理">map 和 set 的原理</h4>
<p>map和set的底层实现主要通过红黑树来实现</p>
<p>红黑树是一种特殊的二叉查找树</p>
<p>1）每个节点或者是黑色，或者是红色</p>
<p>2）根节点是黑色</p>
<p>3） 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</p>
<p>4）如果一个节点是红色的，则它的子节点必须是黑色的</p>
<p>5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>特性4）5）决定了没有一条路径会比其他路径长出2倍，因此红黑树是接近平衡的二叉树。</p>
<h4 id="map-和-unordered_map-区别">map 和 unordered_map 区别</h4>
<p>map是STL中的一个关联容器，提供键值对的数据管理。底层通过红黑树来实现，实际上是二叉排序树和非严格意义上的二叉平衡树。所以在map内部所有的数据都是有序的，且map的查询、插入、删除操作的时间复杂度都是O(logN)。</p>
<p>unordered_map和map类似，都是存储key-value对，可以通过key快速索引到value，不同的是unordered_map不会根据key进行排序。unordered_map底层是一个防冗余的哈希表，存储时根据key的hash值判断元素是否相同，即unoredered_map内部是无序的。</p>
<h4 id="c包含的新特性">C++包含的新特性</h4>
<ul>
<li>列表初始化。在引入C++11之前，仅仅有数组能使用初始化列表，C++11则其它容比如vertor、map、string都可以使用列表初始化</li>
<li>类型指示符 auto，decltype</li>
<li>auto：让编译器通过初始值来推算变量的类型</li>
<li>decltype：从表达式的类型推断出要定义变量的类型</li>
<li>使用基于范围的for循环</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</span><br><span class="line"><span class="comment">// 每行输出str中的一个字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : str)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>lambda表达式</li>
</ul>
<h4 id="智能指针">智能指针</h4>
<p>智能指针是将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。</p>
<p>智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放。</p>
<p>智能指针就是一种栈上创建的对象，函数退出时会调用其析构函数，这个析构函数里面往往就是一堆计数之类的条件判断，如果达到某个条件，就把真正指针指向的空间给释放了。</p>
<blockquote>
<p><strong>注意事项：</strong>不能将指针直接赋值给一个智能指针，一个是类，一个是指针。</p>
</blockquote>
<h4 id="常用的智能指针">常用的智能指针</h4>
<p>C++ 标准库（STL）中，头文件：<code>#include &lt;memory&gt;</code></p>
<blockquote>
<p>C++ 98</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ps (<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C++ 11</p>
</blockquote>
<ul>
<li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li>
<li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li>
</ul>
<p><strong>shared_ptr</strong></p>
<p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p>
<ul>
<li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li>
</ul>
<p><strong>weak_ptr</strong></p>
<p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p>
<ul>
<li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li>
</ul>
<p><strong>unique_ptr</strong></p>
<p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。<strong>采用独占式拥有</strong>，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p>
<ul>
<li>unique_ptr 用于取代 auto_ptr</li>
</ul>
<p><strong>auto_ptr</strong></p>
<p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。</p>
<p>auto_ptr 与 unique_ptr 比较</p>
<ul>
<li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li>
<li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li>
</ul>
<h4 id="智能指针的作用">智能指针的作用</h4>
<p>C++程序设计中使用<strong>堆内存</strong>是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，野指针，程序发生异常时内存泄露等问题等，<strong>使用智能指针能更好的管理堆内存</strong>。</p>
<h4 id="强制类型转换运算符">强制类型转换运算符</h4>
<p>类型转化机制可以分为隐式类型转换和显示类型转化（强制类型转换）</p>
<p>(new-type) expression</p>
<p>new-type (expression)</p>
<p>隐式类型转换比较常见，在混合类型表达式中经常发生；四种强制类型转换操作符：</p>
<p>static_cast、dynamic_cast、const_cast、reinterpret_cast</p>
<p><strong>1）static_cast</strong> ：编译时期的静态类型检查</p>
<p>static_cast &lt; type-id &gt; ( expression )</p>
<p>该运算符把expression转换成type-id类型，在编译时使用类型信息执行转换，在转换时执行必要的检测（指针越界、类型检查），其操作数相对是安全的</p>
<p><strong>2）dynamic_cast</strong>：运行时的检查</p>
<p>用于在集成体系中进行安全的向下转换downcast，即基类指针/引用-&gt;派生类指针/引用</p>
<p>dynamic_cast是4个转换中唯一的RTTI操作符，提供运行时类型检查。</p>
<p>dynamic_cast如果不能转换返回NULL</p>
<p>dynamic_cast转为引用类型的时候转型失败会抛bad_cast</p>
<p>源类中必须要有虚函数，保证多态，才能使用dynamic_cast<source>(expression)</p>
<p><strong>3）const_cast</strong></p>
<p>去除const常量属性，使其可以修改 ; volatile属性的转换</p>
<p><strong>4）reinterpret_cast</strong></p>
<p>通常为了将一种数据类型转换成另一种数据类型</p>
<h4 id="c文件编译与执行的四个阶段">C++文件编译与执行的四个阶段</h4>
<p>1）预处理：根据文件中的预处理指令来修改源文件的内容</p>
<p>2）编译：编译成汇编代码</p>
<p>3）汇编：把汇编代码翻译成目标机器指令</p>
<p>4）链接：链接目标代码生成可执行程序</p>
<h4 id="gcc编译的四个步骤-以最简单的hello.c为例子">gcc编译的四个步骤, 以最简单的hello.c为例子</h4>
<p><strong>一步到位：gcc hello.c</strong></p>
<p>这条命令隐含执行了<br>
（1）预处理<br>
（2）编译<br>
（3）汇编<br>
（4）链接<br>
这里未指定输出文件，默认输出为a.out<br>
gcc编译C源码有四个步骤：<br>
预处理 —-&gt; 编译 —-&gt; 汇编 —-&gt; 链接<br>
现在我们就用gcc的命令选项来逐个剖析gcc过程。</p>
<p><strong>1）预处理(Pre-processing)</strong></p>
<p>在该阶段，编译器将C源代码中的包含的头文件如stdio.h添加进来<br>
参数：”-E”<br>
用法：gcc -E hello.c -o hello.i<br>
作用：将hello.c预处理输出hello.i文件。</p>
<p><strong>2）编译(Compiling)</strong></p>
<p>第二步进行的是编译阶段，在这个阶段中，gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，gcc把代码翻译成汇编语言。<br>
参数：”-S”<br>
用法：gcc –S hello.i –o hello.s<br>
作用：将预处理输出文件hello.i汇编成hello.s文件。</p>
<p><strong>3）汇编(Assembling)</strong></p>
<p>汇编阶段是把编译阶段生成的”.s”文件转成二进制目标代码“.o”文件<br>
参数：“-c”<br>
用法：gcc –c hello.s –o hello.o<br>
作用：将汇编输出文件hello.s编译输出hello.o文件。</p>
<p><strong>4）链接(Link)</strong></p>
<p>在成功编译之后，就进入了链接阶段。<br>
用法：gcc hello.o –o hello<br>
作用：将编译输出文件hello.o链接成最终可执行文件hello。<br>
运行该可执行文件，出现正确的结果如下。<br>
&gt;&gt;&gt; ./hello<br>
Hello World!</p>
<h4 id="gcc-和-g的区别">gcc 和 g++的区别</h4>
<p>简单来说，gcc与g++都是GNU(组织)的一个编译器。需要注意以下几点：</p>
<ol style="list-style-type: decimal">
<li>gcc与g++都可以编译c代码与c++代码。但是：后缀为.c的，gcc把它当做C程序，而g++当做是C++程序；后缀为.cpp的，两者都会认为是C++程序。</li>
<li>编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接。</li>
<li>编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接（当然可以选择手动链接，使用命令如下），所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main<span class="selector-class">.cpp</span> -lstdc++</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="section-2">——</h4>
<h4 id="拷贝构造函数">拷贝构造函数</h4>
<p>拷贝构造函数是一种特殊的构造函数，函数的名称必须和类名称一致，它的唯一的一个参数是本类型的一个引用变量，该参数是const类型，不可变的。例如：类X的拷贝构造函数的形式为X(X&amp; x)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CExample(<span class="keyword">int</span> b)</span><br><span class="line">    &#123; a=b;&#125;</span><br><span class="line">    </span><br><span class="line">    CExample(<span class="keyword">const</span> CExample&amp; C) <span class="comment">// 自定义的拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        a=C.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    CExample B=A;</span><br><span class="line">    B.Show ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用拷贝构造函数三种情况">调用拷贝构造函数（三种情况）</h4>
<p>当用一个已初始化过了的自定义类类型对象去初始化另一个新构造的对象的时候，拷贝构造函数就会被自动调用。也就是说，当类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数：<br>
（1）一个对象以值传递的方式传入函数体<br>
（2）一个对象以值传递的方式从函数返回<br>
（3）一个对象需要通过另外一个对象进行初始化。</p>
<p>如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会自动生成一个默认的拷贝构造函数，该构造函数完成对象之间的浅拷贝。</p>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		A(<span class="keyword">int</span> i)&#123; data = i;&#125; 	<span class="comment">//自定义的构造函数</span></span><br><span class="line">		A(A &amp;&amp; a);  			<span class="comment">//拷贝构造函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">getdata</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> data;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//拷贝构造函数 </span></span><br><span class="line">A::A(A &amp;&amp; a)&#123;</span><br><span class="line">	data = a.data;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"拷贝构造函数执行完毕"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数是对象，值传递，调用拷贝构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdata1</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.getdata();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数是引用，引用传递，不调用拷贝构造函数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdata2</span><span class="params">(A &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.getdata();</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//返回值是对象类型，会调用拷贝构造函数</span></span><br><span class="line"> <span class="function">A <span class="title">getA1</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="function">A <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"> 	<span class="keyword">return</span> a;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">//返回值是引用类型，会调用拷贝构造函数，因为函数体内生成的对象是临时的，离开函数就消失</span></span><br><span class="line"> <span class="function">A&amp; <span class="title">getA2</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="function">A <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"> 	<span class="keyword">return</span> a;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;  </span><br><span class="line">    <span class="function">A <span class="title">b1</span><span class="params">(a1)</span></span>;           		<span class="comment">//用a1初始化b1，调用拷贝构造函数  </span></span><br><span class="line">    A c1=a1;            		<span class="comment">//用a1初始化c1，调用拷贝构造函数  </span></span><br><span class="line">    <span class="keyword">int</span> i=getdata1(a1);        	<span class="comment">//函数形参是类的对象，调用拷贝构造函数  </span></span><br><span class="line">    <span class="keyword">int</span> j=getdata2(a1);      	<span class="comment">//函数形参类型是引用，不调用拷贝构造函数  </span></span><br><span class="line">    A d1=getA1();       		<span class="comment">//调用拷贝构造函数  </span></span><br><span class="line">    A e1=getA2();     			<span class="comment">//调用拷贝构造函数  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="浅拷贝和深拷贝的区别">浅拷贝和深拷贝的区别</h4>
<p>深拷贝和浅拷贝可以简单的理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，如果资源重新分配了就是深拷贝；反之没有重新分配资源，就是浅拷贝。</p>
<p><strong>浅拷贝的问题</strong></p>
<p>浅拷贝资源后在释放资源的时候会产生资源归属不清的情况导致程序运行出错。比如类内成员变量需要动态开辟堆内存，如果实行浅拷贝(位拷贝)，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。</p>
<p><strong>深拷贝的例子</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">　<span class="keyword">public</span>:</span><br><span class="line">　　CA(<span class="keyword">int</span> b,<span class="keyword">char</span>* cstr)</span><br><span class="line">　　&#123;</span><br><span class="line">　　　a=b;</span><br><span class="line">　　　str=<span class="keyword">new</span> <span class="keyword">char</span>[b];</span><br><span class="line">　　　<span class="built_in">strcpy</span>(str,cstr);</span><br><span class="line">　　&#125;</span><br><span class="line">　　CA(<span class="keyword">const</span> CA&amp; C)</span><br><span class="line">　　&#123;</span><br><span class="line">　　　a=C.a;</span><br><span class="line">　　　str=<span class="keyword">new</span> <span class="keyword">char</span>[a]; <span class="comment">//深拷贝</span></span><br><span class="line">　　　<span class="keyword">if</span>(str!=<span class="number">0</span>)</span><br><span class="line">　　　　<span class="built_in">strcpy</span>(str,C.str);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　~CA()</span><br><span class="line">　　&#123;</span><br><span class="line">　　　<span class="keyword">delete</span> str;</span><br><span class="line">　　&#125;</span><br><span class="line">　<span class="keyword">private</span>:</span><br><span class="line">　　<span class="keyword">int</span> a;</span><br><span class="line">　　<span class="keyword">char</span> *str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="function">CA <span class="title">A</span><span class="params">(<span class="number">10</span>,<span class="string">"Hello!"</span>)</span></span>;</span><br><span class="line">　CA B=A;</span><br><span class="line">　B.Show();</span><br><span class="line">　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Reference： <a href="https://www.cnblogs.com/BlueTzar/articles/1223313.html" target="_blank" rel="noopener">1</a></p>
</blockquote>
<h4 id="null-和-nullptr-区别">NULL 和 nullptr 区别</h4>
<p>NULL来自C语言，一般由宏定义实现，C语言中，NULL被定义为(void*)0。而在C++中，NULL则被定义为整数0。nullptr则是C++11的新增关键字，是用来专门区分0、NULL的。</p>
<p>C++不允许直接将void*隐式的转化为其他类型。C++中存在函数重载，比如有两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *a)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果NULL被定义为0，func（NULL）会去调用void func（int），这是不合理的，所以引入nullptr，专门用来区分0、NULL。</p>
<p>nullptr的类型为nullptr_t，能够隐式的转换为任何指针。</p>
<h4 id="lambda-捕获对象的实现待补充">lambda 捕获对象的实现（待补充）</h4>
<h4 id="堆定义的头文件">堆定义的头文件</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="模板类">模板类</h4>
<h4 id="long-long根以前的c-版本有什么区别">long long根以前的C++ 版本有什么区别</h4>
<p>long long是C++的64位整型的基本类型，“现任”长整型。long long占用8个字节，数据表示范围也从int的 [<span class="math inline">\(-2^{31},2^{31}-1\)</span>] ，升级到 [$-2<sup>{63},2</sup>{63}-1]$]。早期的C/C++标准中并没有规定64位长整型的规范，因此不同的编译器对这一模糊概念有不同的定义。</p>
<h4 id="includefile.h-include-file.h-的区别">#include&lt;file.h&gt; #include “file.h” 的区别</h4>
<ul>
<li>前者是从标准库路径寻找</li>
<li>后者是从当前工作路径</li>
</ul>
<h4 id="文件操作">文件操作</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    文件操作：写入+读取字符串</span></span><br><span class="line"><span class="comment">    r: 只读方式打开文本文件，不能写</span></span><br><span class="line"><span class="comment">    w: 只写方式打开文本文件，写了直接覆盖原来的</span></span><br><span class="line"><span class="comment">    a: 只写（添加）方式打开，写了添加在原来的后面</span></span><br><span class="line"><span class="comment">    +: 与上面的 r、 w、 a 结合，表示以读写方式打开文文本件</span></span><br><span class="line"><span class="comment">    b: 与上面的字符组合，表示打开二进制文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ----------------- 打开文件并写入一行语句 ------------------- */</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((fp = fopen(<span class="string">"./file.txt"</span>, <span class="string">"a+"</span>)) == <span class="literal">NULL</span>) &#123;   <span class="comment">// 只写方式打开文件，并用</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"打开文件失败！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    gets(line);                 <span class="comment">// 控制台获取一行</span></span><br><span class="line">    len = <span class="built_in">strlen</span>(line);</span><br><span class="line">    <span class="built_in">fputs</span>(line, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ----------------- 打开文件，读取一行，并输出读取的一行 ------------------- */</span></span><br><span class="line">    <span class="keyword">while</span> ((fp = fopen(<span class="string">"./file.txt"</span>, <span class="string">"rb"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"打开文件失败！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fgets(line, <span class="number">100</span>, fp);    <span class="comment">// 从文件中读取100个字符 </span></span><br><span class="line">    <span class="built_in">puts</span>(line);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="其他问题待整理">**其他问题待整理</h4>
<ul>
<li><p><a href="https://www.zhihu.com/question/34574154" target="_blank" rel="noopener">C++开发准备-知乎</a></p></li>
<li><p><a href="https://www.nowcoder.com/discuss/27739?type=2&amp;order=3&amp;pos=57&amp;page=2" target="_blank" rel="noopener">C++面试汇总</a></p></li>
<li><a href="https://blog.csdn.net/shanghairuoxiao/article/details/72876248" target="_blank" rel="noopener">C++后台开发校招面试常见问题</a></li>
<li><p><a href="https://www.nowcoder.com/discuss/164781" target="_blank" rel="noopener">C++后台开发学习路线</a></p></li>
</ul>
<hr>
<h3 id="操作系统">操作系统</h3>
<h4 id="一进程与线程">一、进程与线程—–</h4>
<ul>
<li>进程是资源分配的基本单位</li>
<li><p>线程是资源调度的基本单位</p></li>
<li>进程有独立的系统资源，一个进程中可以有多个线程，多个线程共享进程资源</li>
<li>进程通信需要借助IPC，线程间可以通过直接读写同一进程中的数据进行通信</li>
<li>进程在创建、切换和销毁时开销比较大，而线程比较小。</li>
<li>进程间不会相互影响；但一个线程挂掉将导致整个进程挂掉</li>
<li>进程试用于多核、多机分布；线程适用于多核</li>
<li>引入进程是为了使多个程序可以并发的执行，以提高系统的资源利用率和吞吐量。</li>
<li><p>引入线程目的是为了减少程序在并发执行过程中的开销，使OS的并发效率更高。</p></li>
</ul>
<h4 id="进程通信与同步">进程通信与同步</h4>
<ul>
<li>进程通信：进程间传输信息</li>
<li>进程同步：控制多个进程按一定顺序执行</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<h4 id="进程之间的通信方式">进程之间的通信方式</h4>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">一、线程</span><br><span class="line">-<span class="ruby"> os.fork()实现多进程</span></span><br><span class="line"><span class="ruby">- multiprocessing 多进程模块（可以跨平台）</span></span><br><span class="line"><span class="ruby">   - Process类 创建多进程，</span></span><br><span class="line"><span class="ruby">   - Pool进程池类</span></span><br><span class="line"><span class="ruby">- 子进程 subprocess模块</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">进程间通信</span></span><br><span class="line"><span class="ruby">- Queue 消息队列</span></span><br><span class="line"><span class="ruby">- Pipes 管道</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">二、线程</span></span><br><span class="line"><span class="ruby">- threading线程模块</span></span><br><span class="line"><span class="ruby">- Lock 加锁，用于线程同步</span></span><br><span class="line"><span class="ruby">注意：由于python中有GIL锁，其把所有线程的执行代码都给伤了锁，所以，多线程在python中只能交替执行，无法利用多个核。</span></span><br><span class="line"><span class="ruby">- ThreadLocal 同于多线程同步，解决了参数在一个线程中个个函数之间相互传递的问题。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>管道（PIPE）</li>
<li>无名管道：一种半双工的通信方式（即数据只能在一个方向上流动），<u>只能在具有亲缘关系的进程间使用（父子进程）</u>
<ul>
<li>优点：简单方便</li>
<li>缺点：</li>
</ul>
<ol style="list-style-type: decimal">
<li>局限于单向通信</li>
<li>只能创建在它的进程以及其有亲缘关系的进程之间</li>
<li>缓冲区有限</li>
</ol></li>
<li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
<ul>
<li>优点：<u>可以实现任意关系的进程间的通信</u></li>
<li>缺点：</li>
</ul>
<ol style="list-style-type: decimal">
<li>长期存于系统中，使用不当容易出错</li>
<li>缓冲区有限</li>
</ol></li>
<li>消息队列（Message Queue）：是消息的链表，存放在内核中，并由消息队列标识符(队列ID)标识</li>
<li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步。</li>
<li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li>
<li>信号量（Semaphore）：是一个计数器，用来控制多个进程对共享资源的访问。主要用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</li>
<li>优点：可以同步进程</li>
<li>缺点：信号量有限</li>
<li>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>
<li>共享内存（Shared Memory）：它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</li>
<li>优点：无须复制，快捷，信息量大</li>
<li>缺点：
<ol style="list-style-type: decimal">
<li>多个进程可以同时操作，所以需要进行同步</li>
<li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li>
</ol></li>
<li>套接字（Socket）：可用于不同主机间的进程通信</li>
<li>优点：
<ol style="list-style-type: decimal">
<li>传输数据为字节级，传输数据可自定义，数据量小、效率高</li>
<li>传输数据时间短，性能高</li>
<li>适合于客户端和服务器端之间信息实时交互</li>
<li>可以加密,数据安全性强</li>
</ol></li>
<li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
<h4 id="进程之间的同步方式不是很清晰">进程之间的同步方式(不是很清晰)</h4>
<p>主要通过信号量，一个计数器，来控制多个进程对共享资源的访问。</p>
<ul>
<li><p>临界区：对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p></li>
<li><p>同步与互斥</p></li>
<li>同步：多个进程按一定顺序执行</li>
<li><p>互斥：多个进程在同一时刻只有一个进程能进入临界区</p></li>
<li><p>信号量：是一个整型变量，可以对其执行 P 和 V 操作</p></li>
<li><strong>P</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><p><strong>V</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 V 操作。</p></li>
</ul>
<p>P 和 V 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>使用信号量实现生产者-消费者问题</li>
</ul>
<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Reference: <a href="https://blog.csdn.net/wuhuagu_wuhuaguo/article/details/78591330" target="_blank" rel="noopener">1</a></p>
</blockquote>
<h4 id="section-3">——</h4>
<h4 id="线程之间的通信同步方式">线程之间的通信/同步方式</h4>
<p><strong>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</strong></p>
<ul>
<li>锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）</li>
<li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li>
<li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
<li>信号量机制(Semaphore)</li>
<li>无名线程信号量</li>
<li>命名线程信号量</li>
<li>信号机制(Signal)：类似进程间的信号处理</li>
<li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li>
</ul>
<hr>
<blockquote>
<p>进程之间的通信方式以及优缺点来源于：<a href="http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977" target="_blank" rel="noopener">进程线程面试题总结</a></p>
</blockquote>
<h4 id="线程安全和线程不安全">线程安全和线程不安全</h4>
<ul>
<li><strong>线程安全</strong>：就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可以使用，不会出现数据不一致或者数据污染。</li>
<li><strong>线程不安全</strong>：就是不提供数据访问保护，有可能多个线程先后更改数据所得到的数据就是脏数据。</li>
</ul>
<h4 id="进程线程的私有共享资源">进程/线程的私有、共享资源</h4>
<p><strong>进程之间私有和共享的资源</strong></p>
<ul>
<li>私有：地址空间、栈、堆、全局变量、寄存器</li>
<li>共享：进程目录、进程 ID、代码段、公共数据，</li>
</ul>
<p><strong>线程之间私有和共享的资源</strong></p>
<ul>
<li>私有：线程栈、寄存器、程序寄存器</li>
<li>共享：地址空间、堆、全局变量、静态变量</li>
</ul>
<h4 id="多进程与多线程-对比">多进程与多线程 对比</h4>
<p><strong>（1）对比</strong></p>
<table>
<thead>
<tr class="header">
<th>对比维度</th>
<th>多进程</th>
<th>多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数据共享、同步</td>
<td>数据共享复杂，需要用 IPC；数据是分开的，同步简单</td>
<td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
<td>各有优势</td>
</tr>
<tr class="even">
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU 利用率低</td>
<td>占用内存少，切换简单，CPU 利用率高</td>
<td>线程占优</td>
</tr>
<tr class="odd">
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr class="even">
<td>编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr class="odd">
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td>一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr class="even">
<td>分布式</td>
<td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody>
</table>
<p><strong>（2）优劣</strong></p>
<table>
<thead>
<tr class="header">
<th>优劣</th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>优点</td>
<td>编程、调试简单，可靠性较高</td>
<td>创建、销毁、切换速度快，内存、资源占用小</td>
</tr>
<tr class="even">
<td>缺点</td>
<td>创建、销毁、切换速度慢，内存、资源占用大</td>
<td>编程、调试复杂，可靠性较差</td>
</tr>
</tbody>
</table>
<p><strong>（3）选择</strong></p>
<ul>
<li>需要频繁创建销毁的优先用线程</li>
<li>需要进行大量计算的优先使用线程</li>
<li>强相关的处理用线程，弱相关的处理用进程</li>
<li>可能要扩展到多机分布的用进程，多核分布的用线程</li>
<li>都满足需求的情况下，用你最熟悉、最拿手的方式</li>
</ul>
<blockquote>
<p>多进程与多线程间的对比、优劣与选择来自：<a href="https://blog.csdn.net/lishenglong666/article/details/8557215" target="_blank" rel="noopener">多线程还是多进程的选择及区别</a></p>
</blockquote>
<h4 id="linux-内核的同步方式">Linux 内核的同步方式</h4>
<p><strong>原因</strong></p>
<p>在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。</p>
<p><strong>同步方式</strong></p>
<ul>
<li>原子操作</li>
<li>信号量（semaphore）</li>
<li>读写信号量（rw_semaphore）</li>
<li>自旋锁（spinlock）</li>
<li>大内核锁（BKL，Big Kernel Lock）</li>
<li>读写锁（rwlock）</li>
<li>大读者锁（brlock-Big Reader Lock）</li>
<li>读-拷贝修改(RCU，Read-Copy Update)</li>
<li>顺序锁（seqlock）</li>
</ul>
<blockquote>
<p>来自：<a href="https://www.ibm.com/developerworks/cn/linux/l-synch/part1/" target="_blank" rel="noopener">Linux 内核的同步机制，第 1 部分</a>、<a href="https://www.ibm.com/developerworks/cn/linux/l-synch/part2/" target="_blank" rel="noopener">Linux 内核的同步机制，第 2 部分</a></p>
</blockquote>
<h4 id="死锁">死锁</h4>
<p>多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p>
<p><strong>原因</strong></p>
<ul>
<li>系统资源不足</li>
<li>资源分配不当</li>
<li>进程运行推进顺序不合适</li>
</ul>
<p><strong>产生条件</strong></p>
<ul>
<li><strong>互斥</strong>：资源不能被共享，只能由一个进程使用</li>
<li><strong>占有和等待</strong>：已经得到资源的进程可以再次申请新的资源</li>
<li><strong>不可抢占</strong>：已经分配的资源不能从相应的进程中被强制地剥夺</li>
<li><strong>循环等待</strong>：系统中若干进程组成环路，改环路中每个进程都在等待相邻进程正占用的资源</li>
</ul>
<p><strong>预防</strong></p>
<ul>
<li><strong>打破互斥条件</strong>：改造独占性资源为虚拟资源，大部分资源已无法改造。</li>
<li><strong>打破不可抢占条件</strong>：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li>
<li><strong>打破占有和等待条件</strong>：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有和等待。</li>
<li><strong>打破循环等待条件</strong>：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li>
<li><strong>有序资源分配法</strong></li>
<li><strong>银行家算法</strong>：当一个进程申请使用资源的时候，银行家算法通过先 <strong>试探</strong> 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。</li>
</ul>
<blockquote>
<p>Reference: <a href="https://www.nowcoder.com/tutorial/93/156e55e0579d4a678e857b34d572c278" target="_blank" rel="noopener">1</a> <a href="https://blog.csdn.net/qq_33414271/article/details/80245715" target="_blank" rel="noopener">银行家算法</a></p>
</blockquote>
<h4 id="进程状态">进程状态</h4>
<div class="figure">
<img src="/2018/04/07/Interview-preparation-of-cpp/进程状态.png">

</div>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>注意一下两点：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h4 id="进程调度算法">进程调度算法</h4>
<p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h5 id="批处理系统">1. 批处理系统</h5>
<p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）</p>
<p><strong>（1）先来先服务 first-come first-serverd（FCFS）</strong></p>
<p>按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>（2）短作业优先 shortest job first（SJF）</strong></p>
<p>按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>（3）最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>按估计剩余时间最短的顺序进行调度。</p>
<h5 id="交互式系统">2. 交互式系统</h5>
<p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>（1）时间片轮转</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
<div class="figure">
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6obdia8LMCOcf7jYrqoOicbSibWDHjZ09bN0EvBBTP9mSvpbnJbWyQ7XkA/640?wx_fmt=jpeg" alt="img">
<p class="caption">img</p>
</div>
<p><strong>（2）优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>（3）多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<div class="figure">
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6Dv4ibTib5yHxPK32EQX36oDnA3QslaKm7nbKvnA1CNzMIgo14qbqCwxA/640?wx_fmt=jpeg" alt="img">
<p class="caption">img</p>
</div>
<h4 id="阻塞与非阻塞">阻塞与非阻塞</h4>
<ul>
<li><strong>阻塞</strong>：是指调用线程或者进程被操作系统挂起。</li>
<li><strong>非阻塞</strong>：是指调用线程或者进程不会被操作系统挂起。</li>
</ul>
<h4 id="并发并行">并发、并行</h4>
<p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p>
<p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p>
<hr>
<h4 id="二内存管理">二、内存管理—–</h4>
<h4 id="物理地址和虚拟地址">物理地址和虚拟地址</h4>
<ul>
<li>将主板上的物理内存条所提供的内存空间定义为物理内存空间，其中每个内存单元的实际地址就是物理地址</li>
<li>将应用程序员看到的内存空间定义为虚拟地址空间(或地址空间)，其中的地址就叫做虚拟地址</li>
</ul>
<h4 id="虚拟内存">虚拟内存</h4>
<p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。<br>
从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p>
<div class="figure">
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6LvLHb8IamLbw9FMpkZCffibFCHDkIXweiaG1kOmTOEPGBeibq57p6vcKg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img">
<p class="caption">img</p>
</div>
<h4 id="分页系统地址映射">分页系统地址映射</h4>
<p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p>
<p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p>
<div class="figure">
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6ASZ0tUoicFz5DcbtCl3VQsHV1pqibHzofTqNl9X1gyicJ3nML9OibYcOXQ/640?wx_fmt=jpeg" alt="img">
<p class="caption">img</p>
</div>
<h4 id="页面置换算法">页面置换算法</h4>
<p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>
<p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>
<p><strong>页面置换算法的主要目标是使页面置换频率最低</strong>（也可以说缺页率最低）。</p>
<h5 id="最佳opt">1. 最佳(OPT)</h5>
<p>Optimal replacement algorithm. 所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p>
<h5 id="最近最久未使用lru">2. 最近最久未使用(LRU)</h5>
<p>Least Recently Used. 虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p>
<p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p>
<div class="figure">
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6tqvKuiaicm2VjHZtQ4YECiaqicdDpibTq01TKT7ibZIF1zzE6FCrH7fPKg4Q/640?wx_fmt=jpeg" alt="img">
<p class="caption">img</p>
</div>
<h5 id="最近未使用nru">3. 最近未使用(NRU)</h5>
<p>Not Recently Used. 每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）</p>
<h5 id="先进先出fifo">4. 先进先出(FIFO)</h5>
<p>First In First Out. 选择换出的页面是最先进入的页面。该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p>
<h5 id="第二次机会算法">5. 第二次机会算法</h5>
<p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p>
<p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p>
<div class="figure">
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6iajVzibicHdtnVHC8FEPXFHdFd4mibDoD6sicRRX5bGkFsXe0Onk2tU4KNA/640?wx_fmt=jpeg" alt="img">
<p class="caption">img</p>
</div>
<h5 id="时钟">6. 时钟</h5>
<p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p>
<div class="figure">
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6zZEXqxCRlP6a2UicyDcNJ8eea3kcDQiayWbd4ObFoWxWxsyrZwUSzbaQ/640?wx_fmt=jpeg" alt="img">
<p class="caption">img</p>
</div>
<h4 id="分段">分段</h4>
<p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p>
<p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p>
<div class="figure">
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6ticRkYufWWnNtRmYCMWNLlSqGu7uN7fOPAicVUNPiapQQVX2MgGkf3fpg/640?wx_fmt=jpeg" alt="img">
<p class="caption">img</p>
</div>
<p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p>
<div class="figure">
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6ibVY2FYzjDPPUia3fAcwzoZjbtgM8j06GqNDd8Iw6NDqGdTYbOsDBvcg/640?wx_fmt=jpeg" alt="img">
<p class="caption">img</p>
</div>
<h4 id="段页式">段页式</h4>
<p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样<strong>既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</strong></p>
<h4 id="分页与分段的比较">分页与分段的比较</h4>
<ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的。</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li>
<li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
<h4 id="三设备管理">三、设备管理—–</h4>
<h4 id="磁盘结构">磁盘结构</h4>
<ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
</ul>
<div class="figure">
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6rRjVuJAgsQibQgnT55AZQXSe6utFsLTeiaRtoMCrBjlq18b43eojrBmA/640?wx_fmt=jpeg" alt="img">
<p class="caption">img</p>
</div>
<h4 id="磁盘调度算法">磁盘调度算法</h4>
<p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<h5 id="先来先服务">1. 先来先服务</h5>
<p>FCFS, First Come First Served.按照磁盘请求的顺序进行调度。优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<h5 id="最短寻道时间优先">2. 最短寻道时间优先</h5>
<p>SSTF, Shortest Seek Time First</p>
<p>优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
<div class="figure">
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6luAMhnIplsx90WWgCcnn0403kaOJhGEcJqBgHqNtPSEGR1icOicMdavw/640?wx_fmt=jpeg" alt="img">
<p class="caption">img</p>
</div>
<h5 id="电梯算法">3. 电梯算法</h5>
<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<div class="figure">
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeIRSoyibgdfYqrwFweWloZmY6nakeMzibswkEQROAIVD9d084aWDnYyPFtfAO31araPMa7JVpiarx507g/640?wx_fmt=jpeg" alt="img">
<p class="caption">img</p>
</div>
<blockquote>
<p>Reference: <a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1564993921&amp;ver=1771&amp;signature=rKE6XILKx6Av-cIwm1bAefi*BXcFrsIsiJ5bZuoGGmJS7af2i1okHsRL3NJV01IyTqXzs1j2rTqPfNhzE31XmMhfddiXdCkryjWj1ZSx8UMR5MJlcOGDoHdJbq30uIqi&amp;new=1" target="_blank" rel="noopener">操作系统面试整理</a></p>
</blockquote>
<hr>
<h3 id="python">Python</h3>
<blockquote>
<p><a href="https://github.com/SmileLingyong/interview_python" target="_blank" rel="noopener">Python面试集合</a></p>
</blockquote>
<h4 id="常用函数">常用函数</h4>
<blockquote>
<p>Reference: <a href="https://www.runoob.com/python/python-strings.html" target="_blank" rel="noopener">1</a></p>
</blockquote>
<ul>
<li><strong>map()</strong></li>
</ul>
<blockquote>
<p>语法：<strong><code>map(func, *iterable)</code>：将func用于每个iterable对象</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str = input()								<span class="comment"># [1, 2, 3]</span></span><br><span class="line">pattern = re.compile(<span class="string">r'\d+'</span>)</span><br><span class="line">num_str_list = re.findall(pattern, str)		<span class="comment"># ['1', '2', '3']</span></span><br><span class="line">num_list = list(map(int, num_str_list))		<span class="comment"># [1, 2, 3]</span></span><br><span class="line">print(num_list)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(map(<span class="keyword">lambda</span> a,b:a+b,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])) <span class="comment"># [6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>reduce()</strong></li>
</ul>
<p><strong>reduce()</strong> 函数会对参数序列中元素进行累积。函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</p>
<blockquote>
<p>语法：<strong><code>reduce(function, iterable[, initializer])</code></strong></p>
<p>参数：</p>
<ul>
<li>function – 函数，有两个参数</li>
<li>iterable – 可迭代对象</li>
<li>initializer – 可选，初始参数</li>
</ul>
<p>返回： 返回函数计算结果。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span> :</span>            <span class="comment"># 两数相加</span></span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">reduce(add, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])   <span class="comment"># 计算列表和：1+2+3+4+5</span></span><br><span class="line"><span class="comment"># 15</span></span><br><span class="line">reduce(<span class="keyword">lambda</span> x, y: x+y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])  <span class="comment"># 使用 lambda 匿名函数</span></span><br><span class="line"><span class="comment"># 15</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>zip()</strong></li>
</ul>
<p><strong>zip()</strong> 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</p>
<p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</p>
<blockquote>
<p>语法：<strong><code>zip([iterable, ...])</code></strong></p>
<p>参数说明：iterabl：一个或多个迭代器;</p>
<p>返回元祖列表</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zipped = zip(a,b)     <span class="comment"># 打包为元组的列表</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip(a,c)              <span class="comment"># 元素个数与最短的列表一致</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip(*zipped)          <span class="comment"># 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>strip()</strong></li>
</ul>
<p>移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。<strong>注意：</strong>该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"00000003210Runoob01230000000"</span>; </span><br><span class="line"><span class="keyword">print</span> str.strip( <span class="string">'0'</span> );  <span class="comment"># 去除首尾字符 0</span></span><br><span class="line"></span><br><span class="line">str2 = <span class="string">"   Runoob      "</span>;   <span class="comment"># 去除首尾空格</span></span><br><span class="line"><span class="keyword">print</span> str2.strip();</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取一行，并提取其中的数字，存放与list中</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = sys.stdin.readline().strip()  <span class="comment"># .strip()用于出去该行末尾的空格或回车</span></span><br><span class="line">    <span class="keyword">if</span> line == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        nums = list(map(int, list(line.split(<span class="string">' '</span>))))</span><br><span class="line">        print(nums)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>split()</strong></li>
</ul>
<blockquote>
<p>通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"Line1-abcdef \nLine2-abc \nLine4-abcd"</span>;</span><br><span class="line">print(str.split( ))       <span class="comment"># 以空格为分隔符，包含 \n</span></span><br><span class="line">print(str.split(<span class="string">' '</span>, <span class="number">1</span> )) <span class="comment"># 以空格为分隔符，分隔成两个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ['Line1-abcdef', 'Line2-abc', 'Line4-abcd']</span></span><br><span class="line"><span class="comment"># ['Line1-abcdef', '\nLine2-abc \nLine4-abcd']</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>join()</strong></li>
</ul>
<p>Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。</p>
<blockquote>
<p>语法：<strong><code>str.join(sequence)</code></strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"-"</span>;</span><br><span class="line">seq = (<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>); <span class="comment"># 字符串序列</span></span><br><span class="line">print(str.join(seq)); <span class="comment"># a-b-c</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>find()</strong></li>
</ul>
<p>检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。</p>
<blockquote>
<p>语法：<strong><code>str.find(str, beg=0, end=len(string))</code></strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"this is string example....wow!!!"</span>;</span><br><span class="line">str2 = <span class="string">"exam"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> str1.find(str2);		<span class="comment"># 15</span></span><br><span class="line"><span class="keyword">print</span> str1.find(str2, <span class="number">10</span>);	<span class="comment"># 15</span></span><br><span class="line"><span class="keyword">print</span> str1.find(str2, <span class="number">40</span>);	<span class="comment"># -1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>index()</strong></li>
</ul>
<p>Python index() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，该方法与 python find()方法一样，只不过如果str不在 string中会报一个异常。</p>
<blockquote>
<p>语法：<strong>str.index(str, beg=0, end=len(string))</strong></p>
<p>如果包含子字符串返回开始的索引值，否则抛出异常。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"this is string example....wow!!!"</span>;</span><br><span class="line">str2 = <span class="string">"exam"</span>;</span><br><span class="line"><span class="keyword">print</span> str1.index(str2); 	<span class="comment"># 15</span></span><br><span class="line"><span class="keyword">print</span> str1.index(str2, <span class="number">10</span>); <span class="comment"># 15</span></span><br><span class="line"><span class="keyword">print</span> str1.index(str2, <span class="number">40</span>); <span class="comment"># 报异常</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>count()</strong></li>
</ul>
<p>用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。</p>
<blockquote>
<p>语法：<strong><code>str.count(sub, start= 0,end=len(string))</code></strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"this is string example....wow!!!"</span>;</span><br><span class="line"> </span><br><span class="line">sub = <span class="string">"i"</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"str.count(sub, 4, 40) : "</span>, str.count(sub, <span class="number">4</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">sub = <span class="string">"wow"</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"str.count(sub) : "</span>, str.count(sub)</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.count(sub, 4, 40) :  2</span></span><br><span class="line"><span class="comment"># str.count(sub) :  1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>逆序迭代</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正序循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># 0 1 2 3 4 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆序循环</span></span><br><span class="line"><span class="comment"># 方法一：</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)[::<span class="number">-1</span>]:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># 4 3 2 1 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, <span class="number">-1</span>, <span class="number">-1</span>):  <span class="comment"># 注意这里是4</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># 4 3 2 1 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三：</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">5</span>)):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># 4 3 2 1 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>range()</strong> 定义步长</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>):</span><br><span class="line">	print(i, end=<span class="string">','</span>)</span><br><span class="line"><span class="comment"># 0,2,4</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>enumerate()</strong></li>
</ul>
<p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中.</p>
<blockquote>
<p>语法：<strong><code>enumerate(sequence, [start=0])</code></strong></p>
<p>参数：</p>
<ul>
<li>sequence – 一个序列、迭代器或其他支持迭代对象。</li>
<li>start – 下标起始位置。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(seq):</span><br><span class="line">	<span class="keyword">print</span> i, element</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>help()</strong></li>
</ul>
<p>用于查看函数或者模块用途的详细说明</p>
<ul>
<li><strong>dir()</strong></li>
</ul>
<p>dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法<code>__dir__()</code>，该方法将被调用。如果参数不包含 <code>__dir__()</code>，该方法将最大限度地收集参数信息。</p>
<ul>
<li><strong>type()</strong></li>
</ul>
<p>只有第一个参数则返回对象的类型，三个参数返回新的类型对象</p>
<blockquote>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; type(object)</span><br><span class="line">&gt; type(name, bases, dict)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>参数：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">name</span>  <span class="comment">-- 类的名称。</span></span><br><span class="line">&gt; bases <span class="comment">-- 基类的元组。</span></span><br><span class="line">&gt; dict  <span class="comment">-- 字典，类内定义的命名空间变量。</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个参数实例</span></span><br><span class="line">type(<span class="number">1</span>)</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三个参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span><span class="params">(object)</span>:</span></span><br><span class="line">   a = <span class="number">1</span></span><br><span class="line">X = type(<span class="string">'X'</span>, (object,), dict(a=<span class="number">1</span>))  <span class="comment"># 产生一个新的类型 X</span></span><br><span class="line">print(X)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">X</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="sort-和-sorted-区别">sort() 和 sorted() 区别</h4>
<ol style="list-style-type: decimal">
<li>sort 是应用在 list 上的方法，属于列表的成员方法，sorted 可以对所有可迭代的对象进行排序操作。</li>
<li>list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</li>
<li>sort使用方法为ls.sort()，而sorted使用方法为sorted(ls)</li>
</ol>
<ul>
<li>使用一个key函数，把字符串映射为忽略大小写排序</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower)</span><br><span class="line"><span class="comment"># ['about', 'bob', 'Credit', 'Zoo']</span></span><br></pre></td></tr></table></figure>
<ul>
<li>要进行反向排序，不必改动 key 函数，可以传入第三个参数 <strong>reverse=True</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># ['Zoo', 'Credit', 'bob', 'about']</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Reference: <a href="https://blog.csdn.net/u013759354/article/details/80243705" target="_blank" rel="noopener">*</a></p>
</blockquote>
<h4 id="random随机数随机字符串">random随机数/随机字符串</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">print( random.randint(<span class="number">1</span>, <span class="number">10</span>) )        <span class="comment"># 产生 1 到 10 的一个整数型随机数  </span></span><br><span class="line">print( random.randrange(<span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>) )   <span class="comment"># 生成从1到100的间隔为2的随机整数</span></span><br><span class="line"></span><br><span class="line">print( random.random() )             <span class="comment"># 产生 0 到 1 之间的随机浮点数</span></span><br><span class="line">print( random.uniform(<span class="number">1.1</span>, <span class="number">5.4</span>) )     <span class="comment"># 产生  1.1 到 5.4 之间的随机浮点数，区间可以不是整数</span></span><br><span class="line"></span><br><span class="line">print( random.choice(<span class="string">'tomorrow'</span>) )   <span class="comment"># 随机字符，从序列中随机选取一个元素</span></span><br><span class="line"><span class="keyword">print</span> random.choice([<span class="string">'剪刀'</span>, <span class="string">'石头'</span>, <span class="string">'布'</span>])  <span class="comment"># 随机选取字符串</span></span><br><span class="line"><span class="keyword">print</span> random.sample(<span class="string">'zyxwvutsrqponmlkjihgfedcba'</span>, <span class="number">5</span>) <span class="comment"># 多个字符中生成指定数量的随机字符</span></span><br><span class="line"></span><br><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> random.shuffle(items)			 <span class="comment"># 打乱排序</span></span><br></pre></td></tr></table></figure>
<h4 id="三元运算">三元运算</h4>
<p>不像C++，我们在Python中没有 <code>?:</code>，但我们有这个：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[on true] <span class="keyword">if</span> [expression] <span class="keyword">else</span> [on false]</span><br></pre></td></tr></table></figure>
<p>如果表达式为True，就执行[on true]中的语句。否则，就执行[on false]中的语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a,b = <span class="number">2</span>,<span class="number">3</span></span><br><span class="line">min=a <span class="keyword">if</span> a&lt;b <span class="keyword">else</span> b</span><br><span class="line">print(min)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<h4 id="常用的python模块">常用的Python模块</h4>
<ul>
<li>os：与操作系统相关联的函数。提供了丰富的方法来处理文件和目录。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">os.remove(‘path/filename’) 删除文件</span><br><span class="line">os.rename(oldname, newname) 重命名文件</span><br><span class="line">os.mkdir/makedirs(<span class="string">'dirname'</span>)创建目录/多层目录</span><br><span class="line">os.rmdir/removedirs(<span class="string">'dirname'</span>) 删除目录/多层目录</span><br><span class="line">os.listdir(<span class="string">'dirname'</span>) 列出指定目录的文件</span><br><span class="line">os.getcwd() 取得当前工作目录</span><br><span class="line">os.path.exists() 是否存在</span><br><span class="line">os.path.isabs() 是否为绝对路径</span><br><span class="line">os.path.isdir() 是否为目录</span><br><span class="line">os.path.isfile() 是否为文件</span><br></pre></td></tr></table></figure>
<ul>
<li>sys: 通常用于命令行参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sys.exit(n) 退出程序，正常退出时exit(<span class="number">0</span>)</span><br><span class="line">sys.stdin 标准输入</span><br><span class="line">sys.stdout 标准输出</span><br><span class="line">sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</span><br></pre></td></tr></table></figure>
<ul>
<li>time：time.time() 用于获取当前时间戳</li>
<li>re: 正则匹配</li>
<li>math: 数学运算</li>
<li>datetime:处理日期时间</li>
<li>numpy: 数据科学包</li>
</ul>
<h4 id="模块-和-包">模块 和 包</h4>
<p><strong>模块</strong>： 一个.py 文件就称之为一个模块（ Module）</p>
<ul>
<li>大大提高了代码的可维护性</li>
<li>还可以避免函数名和变量名冲突</li>
</ul>
<blockquote>
<p>这个 fibonacci.py 文件就是一个模块</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_yield</span><span class="params">(n)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a+b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> fib_yield(n):</span><br><span class="line">        print(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用 if __name__ == "__main__": 在模块代码中定义一些测试代码。        </span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    fib(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>然后在python解释器或其他文件中 <code>import</code> 它</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fibonacci</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> fibonacci.fib_yield(<span class="number">5</span>):</span><br><span class="line">    print(num)</span><br></pre></td></tr></table></figure>
<p><strong>包</strong>： 按目录来组织模块的方法，成为包。即包是一个包含<code>__init__.py</code> 文件的目录，该目录下一定得有这个 <code>__init__.py</code> 文件和其它模块或子包。</p>
<ul>
<li>通过包来组织模块，避免冲突</li>
</ul>
<h4 id="几种魔法方法">几种魔法方法</h4>
<p><code>__init__</code>:对象初始化方法</p>
<p><code>__new__</code>:创建对象时候执行的方法，单列模式会用到</p>
<p><code>__str__</code>:当使用print输出对象的时候，只要自己定义了<code>__str__</code>(self)方法，那么就会打印从在这个方法中return的数据</p>
<p><code>__del__</code>:删除对象执行的方法</p>
<p>补充：</p>
<p><strong><code>__new__ 和 __init__ 区别</code></strong></p>
<ol style="list-style-type: decimal">
<li><code>__new__</code>是一个静态方法,而<code>__init__</code>是一个实例方法.</li>
<li><code>__new__</code>方法会返回一个创建的实例,而<code>__init__</code>什么都不返回.</li>
<li>只有在<code>__new__</code>返回一个cls的实例时后面的<code>__init__</code>才能被调用.</li>
<li>当创建一个新实例时调用<code>__new__</code>,初始化一个实例时用<code>__init__</code>.</li>
</ol>
<h4 id="单利模式">单利模式</h4>
<ul>
<li>使用 new 关键字实现单例模式</li>
</ul>
<blockquote>
<p>_instance 用来存放实例，如果 _instance 为 None，则新建实例，否则直接返回 _instance 存放的实例。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = object.__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">single1 = Single()</span><br><span class="line">single2 = Single()</span><br><span class="line">print(id(single1) == id(single2))  <span class="comment"># id用于获取对象的内存地址</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>装饰器版本</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> getinstance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br></pre></td></tr></table></figure>
<h4 id="深拷贝和浅拷贝">深拷贝和浅拷贝</h4>
<ul>
<li><strong>直接赋值：</strong>其实就是对象的引用（别名）。</li>
<li><strong>浅拷贝(copy)：</strong>拷贝父对象，不会拷贝对象的内部的子对象。</li>
<li><strong>深拷贝(deepcopy)：</strong> copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</li>
</ul>
<p>1、<strong>b = a: </strong>赋值引用，a 和 b 都指向同一个对象。</p>
<div class="figure">
<img src="/2018/04/07/Interview-preparation-of-cpp/copy_01.png">

</div>
<p><strong>2、b = a.copy():</strong> 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。</p>
<div class="figure">
<img src="/2018/04/07/Interview-preparation-of-cpp/copy_02.png">

</div>
<p><strong>b = copy.deepcopy(a):</strong> 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。</p>
<div class="figure">
<img src="/2018/04/07/Interview-preparation-of-cpp/copy_03.png">

</div>
<ul>
<li>如果给定一个正整数数N，对于一个最小位是2的s次幂的数，需要多少位才能表示这个数？如何确定数字系统中的参数位数。</li>
</ul>
<h4 id="range-和-xrange-区别">range 和 xrange 区别</h4>
<blockquote>
<p><strong>Python2.7</strong></p>
</blockquote>
<ul>
<li><strong>range</strong> ：返回一个列表 list，type是 <type 'list'> 类型，会直接分配相应的内存空间给 list</type></li>
<li><strong>xrange</strong>：返回一个生成器，type 是 <type 'xrange'> 类型，在for in 循环中中，每次调用就生成一个。</type></li>
</ul>
<blockquote>
<p><strong>Python3</strong></p>
</blockquote>
<p>Python3 中取消了 <code>xrange</code> 函数，此时的 <code>range</code> 就是 <code>xrange</code> 函数</p>
<ul>
<li><strong>range</strong>： 返回一个生成器，type 是 <type 'range'>，并没有将数据完全实例化，for 循环每次用的时候返回一个，这样可以大大节省空间，优化性能。</type></li>
</ul>
<h4 id="内建数据类型">内建数据类型</h4>
<ul>
<li>整型–int</li>
<li>布尔型–bool</li>
<li>字符串–str</li>
<li>列表–list</li>
<li>元组–tuple</li>
<li>字典–dict</li>
</ul>
<h4 id="list-和-tuple-区别">list 和 tuple 区别</h4>
<p>两者的主要区别是列表是可变的，而元组是不可变的。一般元组能做到的，列表也能做到，但有两个原因是列表不能替代的：</p>
<ul>
<li>不能将列表当做字典的key，而元组可以。</li>
<li>元组作为很多内建函数和方法的返回值存在。</li>
</ul>
<h4 id="列表元组集合字典的区别">列表、元组、集合、字典的区别</h4>
<table>
<thead>
<tr class="header">
<th></th>
<th>列表</th>
<th>元组</th>
<th>集合</th>
<th>字典</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英文</td>
<td>list</td>
<td>tuple</td>
<td>set</td>
<td>dict</td>
</tr>
<tr class="even">
<td>可否读写</td>
<td>读写</td>
<td>只读</td>
<td>读写</td>
<td>读写</td>
</tr>
<tr class="odd">
<td>可否重复</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr class="even">
<td>存储方式</td>
<td>值</td>
<td>值</td>
<td>键(不能重复)</td>
<td>键值对(键不能重复)</td>
</tr>
<tr class="odd">
<td>是否有序</td>
<td>有序</td>
<td>有序</td>
<td>无序</td>
<td>无序，自动正序</td>
</tr>
<tr class="even">
<td>初始化</td>
<td><code>[1,'a']</code></td>
<td><code>('a', 1)</code></td>
<td><code>set([1,2])</code> 或 <code>{1,2}</code></td>
<td><code>{'a':1,'b':2}</code></td>
</tr>
<tr class="odd">
<td>添加</td>
<td><code>append</code></td>
<td>只读</td>
<td><code>add</code></td>
<td><code>d['key'] = 'value'</code></td>
</tr>
<tr class="even">
<td>读元素</td>
<td><code>l[2:]</code></td>
<td><code>t[0]</code></td>
<td>无</td>
<td><code>d['a']</code></td>
</tr>
</tbody>
</table>
<h5 id="列表元组转其他">列表元组转其他</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表转集合(去重)</span></span><br><span class="line">list1 = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">set(list1)</span><br><span class="line"><span class="comment"># &#123;6, 7, 8, 9&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#两个列表转字典</span></span><br><span class="line">list1 = [<span class="string">'key1'</span>,<span class="string">'key2'</span>,<span class="string">'key3'</span>]</span><br><span class="line">list2 = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>]</span><br><span class="line">dict(zip(list1,list2))</span><br><span class="line"><span class="comment"># &#123;'key1': '1', 'key2': '2', 'key3': '3'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#嵌套列表转字典</span></span><br><span class="line">list3 = [[<span class="string">'key1'</span>,<span class="string">'value1'</span>],[<span class="string">'key2'</span>,<span class="string">'value2'</span>],[<span class="string">'key3'</span>,<span class="string">'value3'</span>]]</span><br><span class="line">dict(list3)</span><br><span class="line"><span class="comment"># &#123;'key1': 'value1', 'key2': 'value2', 'key3': 'value3'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表、元组转字符串</span></span><br><span class="line">list2 = [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="string">''</span>.join(list2)</span><br><span class="line"><span class="comment"># 'aab'</span></span><br><span class="line"></span><br><span class="line">tup1 = (<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"><span class="string">''</span>.join(tup1)</span><br><span class="line"><span class="comment"># 'aab'</span></span><br></pre></td></tr></table></figure>
<h5 id="字典转其他">字典转其他</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典转换为字符串</span></span><br><span class="line">dic1 = &#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line">str(dic1)</span><br><span class="line"><span class="comment"># "&#123;'a': 1, 'b': 2&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典key和value互转</span></span><br><span class="line">dic2 = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line">&#123;value:key <span class="keyword">for</span> key, value <span class="keyword">in</span> dic2.items()&#125;</span><br><span class="line"><span class="comment"># &#123;1: 'a', 2: 'b', 3: 'c'&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="字符串转其他">字符串转其他</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串转列表</span></span><br><span class="line">s = <span class="string">'aabbcc'</span></span><br><span class="line">list(s)</span><br><span class="line"><span class="comment"># ['a', 'a', 'b', 'b', 'c', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串转元组</span></span><br><span class="line">tuple(s)</span><br><span class="line"><span class="comment"># ('a', 'a', 'b', 'b', 'c', 'c')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串转集合</span></span><br><span class="line">set(s)</span><br><span class="line"><span class="comment"># &#123;'a', 'b', 'c'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串转字典</span></span><br><span class="line">dic2 = eval(<span class="string">"&#123;'name':'ljq', 'age':24&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切分字符串</span></span><br><span class="line">a = <span class="string">'a b c'</span></span><br><span class="line">a.split(<span class="string">' '</span>)</span><br><span class="line"><span class="comment"># ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>
<h4 id="collections-模块">collections 模块</h4>
<h5 id="defaultdict">defaultdict</h5>
<p>dict在使用时，当key值不存在时，直接添加value时会出现错误，使用defaultdict可以很好的规避该错误。defaultdict是对字典类型的补充，它可以给字典的值设置一个类型，<strong>当key不存在时可以自动生成相应类型的value</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最长无重复字符子串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstringIII</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    方法三：使用滑动窗口，左右指针，套用模板</span></span><br><span class="line"><span class="string">    （1）使用双指针，初始化 left = right = 0, 把索引闭区间 [left, right] 称为窗口</span></span><br><span class="line"><span class="string">    （2）先不断的增加right指针，扩大窗口 [left, right]，同时记录当前窗口中每个字符出现的次数，</span></span><br><span class="line"><span class="string">        如果某个字符次数超过1次，则说明有重复字符，然后就需要更新left左指针，缩小窗口范围，</span></span><br><span class="line"><span class="string">        直到窗口中每个字符最多只出现一次</span></span><br><span class="line"><span class="string">    （3）每次更新right，我们都需要更新当前最长不重复的最长子串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">    str_dict = defaultdict(int)     <span class="comment"># 作为计数器，记录窗口中字符穿线次数</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="number">0</span></span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; len(s):</span><br><span class="line">        <span class="keyword">if</span> str_dict[s[right]] &gt; <span class="number">0</span>:</span><br><span class="line">            counter += <span class="number">1</span></span><br><span class="line">        str_dict[s[right]] += <span class="number">1</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> counter &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> str_dict[s[left]] &gt; <span class="number">1</span>:</span><br><span class="line">                counter -= <span class="number">1</span></span><br><span class="line">            str_dict[s[left]] -= <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        max_len = max(max_len, right - left)</span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h5 id="ordereddict">orderedDict</h5>
<p>在Python3.6之前的字典是无序的，但是有时候我们需要保持字典的有序性，orderDict可以在dict的基础上实现字典的有序性，这里的有序指的是按照字典key插入的顺序来排列，这样就实现了一个先进先出的dict，当容量超出限制时，先删除最早添加的key。<br>
举例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line">original_dict = &#123;<span class="string">'a'</span>: <span class="number">2</span>, <span class="string">'b'</span>: <span class="number">4</span>, <span class="string">'c'</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> original_dict.items():</span><br><span class="line">    print(key, value)</span><br><span class="line"></span><br><span class="line">ordered_dict = OrderedDict([(<span class="string">'a'</span>, <span class="number">2</span>), (<span class="string">'b'</span>, <span class="number">4</span>), (<span class="string">'c'</span>, <span class="number">5</span>)])</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> ordered_dict.items():</span><br><span class="line">    print(key, value)</span><br><span class="line"><span class="comment"># a 2</span></span><br><span class="line"><span class="comment"># b 4</span></span><br><span class="line"><span class="comment"># c 5</span></span><br><span class="line"><span class="comment"># a 2</span></span><br><span class="line"><span class="comment"># b 4</span></span><br><span class="line"><span class="comment"># c 5</span></span><br></pre></td></tr></table></figure>
<h5 id="deque">deque</h5>
<p>Python中的list是基于数组实现的，所以，查找容易，但是插入和删除操作时间复杂度较大。<br>
deque就是为了高效实现插入和删除操作的双向列表，适合用于队列和栈，而且线程安全。<br>
list只提供了append和pop方法来从list的尾部插入或者删除元素，deque新增了appendleft/popleft等方法可以更高效的在元素的开头来<strong>插入/删除</strong>元素。(可以进行双向操作元素，十分方便)<br>
举例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">d = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">d.extendleft([<span class="number">0</span>])	</span><br><span class="line">print(d)			<span class="comment"># deque([0, 1, 2, 3, 4, 5])</span></span><br><span class="line">d.extend([<span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">d.popleft()</span><br><span class="line">print(d)			<span class="comment"># deque([1, 2, 3, 4, 5, 6, 7])</span></span><br></pre></td></tr></table></figure>
<h5 id="counter">Counter</h5>
<p>字典子类，为可以哈希的对象计数。可以实现对一个对象中的元素进行计数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">test_counter_data = [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'sheep'</span>, <span class="string">'cat'</span>, <span class="string">'dog'</span>]</span><br><span class="line">counter_data = Counter()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> test_counter_data:</span><br><span class="line">    counter_data[item] += <span class="number">1</span></span><br><span class="line">print(counter_data)</span><br><span class="line"><span class="comment"># Counter(&#123;'cat': 2, 'dog': 2, 'sheep': 1&#125;)</span></span><br></pre></td></tr></table></figure>
<h5 id="namedtuple">namedtuple</h5>
<p>元组子类。<br>
我们知道，Python中元组的一个重要特征就是元素不可增删改，而查找tuple元素时一般采取索引。<br>
使用namedtuple(typename, field_name)可以命名tuple中的元素，之后便可使用名字来查找tuple中的值，有点类似于字典中的查找。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">animal = namedtuple(<span class="string">'animal'</span>, <span class="string">'type age'</span>)</span><br><span class="line">mark = animal(type=<span class="string">'dog'</span>, age=<span class="number">2</span>)</span><br><span class="line">print(mark.type)  	<span class="comment"># dog</span></span><br></pre></td></tr></table></figure>
<p>使用namedtuple可以提高代码的可读性和文档性。</p>
<h4 id="heapq">heapq</h4>
<h4 id="list删除元素">list删除元素</h4>
<ol style="list-style-type: decimal">
<li><strong>使用 <code>del</code> 删除指定元素</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">del</span> li[<span class="number">3</span>]</span><br><span class="line">print(li)</span><br><span class="line"><span class="comment"># Output [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<ol start="2" style="list-style-type: decimal">
<li><strong>使用list方法 <code>pop</code> 删除元素</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">li.pop(<span class="number">2</span>)</span><br><span class="line">print(li)</span><br><span class="line"><span class="comment"># Output [1, 2, 4]</span></span><br></pre></td></tr></table></figure>
<p>注：指定pop参数，将会删除该位置的元素；无参数时默认删除最后一个元素</p>
<ol start="3" style="list-style-type: decimal">
<li><strong>使用切片删除元素</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">li = li[:<span class="number">2</span>] + li[<span class="number">3</span>:]</span><br><span class="line">print(li)</span><br><span class="line"><span class="comment"># Output [1, 2, 4]</span></span><br></pre></td></tr></table></figure>
<ol start="4" style="list-style-type: decimal">
<li><strong>使用list方法 <code>remove</code> 删除指定值的元素</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">li.remove(<span class="number">3</span>)</span><br><span class="line">print(li)</span><br><span class="line"><span class="comment"># Output [1, 2, 4]</span></span><br></pre></td></tr></table></figure>
<p>注：remove方法删除指定值的元素，与其他方法不同。</p>
<h4 id="创建二维数组">创建二维数组</h4>
<p><strong>(1) 直接创建法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
<p>简单粗暴，不过太麻烦，一般不用。</p>
<p><strong>(2) 列表生成式法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m)] <span class="keyword">for</span> j <span class="keyword">in</span> range(n)]</span><br></pre></td></tr></table></figure>
<p><strong>(3) 使用模块numpy创建</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">test = np.zeros((m, n), dtype=np.int)</span><br></pre></td></tr></table></figure>
<h4 id="下划线命名">下划线命名</h4>
<ul>
<li><p><code>_xxx</code>：私有化属性或方法，不能用<code>from somemodule import *</code> 导入，类对象和子类可以访问。但按照约定俗成的规定，定义成这样就表示，虽然可以访问，但还是要把其看成是私有的，不要随便访问。</p></li>
<li><code>__xxx</code>：表示是一个私有成员，它无法直接像公有成员一样访问，但可以通过 <code>对象名._类名__xxx</code> 方式访问。</li>
<li><p><code>__xxx__</code>：特殊成员，特殊成员是可以直接访问的，其不是 private 成员，例如： <code>__init__()</code> 、<code>__del__()</code> 这样的魔法函数。</p></li>
</ul>
<blockquote>
<p>Reference: <a href="https://segmentfault.com/a/1190000002611411" target="_blank" rel="noopener">1</a> <a href="https://www.zhihu.com/question/19754941" target="_blank" rel="noopener">2</a></p>
</blockquote>
<h4 id="函数参数">！函数参数</h4>
<ol style="list-style-type: decimal">
<li><strong><code>必选参数</code></strong>： 必须要传入的参数。如定义一个函数 <code>fun(x): return x</code>，x 则为必选参数。</li>
<li><strong><code>默认参数</code></strong>：一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ <code>fun(x, n=2): return x * n</code></li>
<li><strong><code>*args</code></strong> <strong>可变参数</strong>：args 接收的是一个 <strong>tuple</strong></li>
<li><code>**kw</code> 是<strong>关键字参数</strong>， kw 接收的是一个 <strong>dict</strong></li>
</ol>
<p>调用函数时，如何传入可变参数和关键字参数语法：</p>
<ul>
<li><strong>可变参数</strong>既可以直接传入： <code>func(1, 2, 3)</code>，又可以先组装 list 或 tuple，再通过 <code>*args</code> 传入： <code>func(*(1, 2, 3))</code></li>
<li><strong>关键字参数</strong>既可以直接传入： <code>func(a=1, b=2)</code>，又可以先组装 dict，再通过 <code>**kw</code> 传入： <code>func(**{'a': 1, 'b': 2})</code></li>
</ul>
<ol start="5" style="list-style-type: decimal">
<li><strong>命名关键字参数</strong>： 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。<u><strong>注意：</strong>定义命名的关键字参数在没有可变参数的情况下不要忘了<strong>写分隔符</strong>*，否则定义的将是位置参数。</u></li>
</ol>
<blockquote>
<p>定义参数顺序必须是：<strong>必选参数、默认参数、可变参数、命名关键字参数、关键字参数</strong>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a, b, c=<span class="number">0</span>, *args, **kw)</span>:</span> <span class="comment"># a,b必选参数、c默认参数、*args可变参数、**关键字参数</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'args ='</span>, args, <span class="string">'kw ='</span>, kw)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a, b, c=<span class="number">0</span>, *, age, **kw)</span>:</span>  <span class="comment"># a,b必选参数、c默认参数、age命名关键字参数、**kw关键字参数</span></span><br><span class="line">	print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'age ='</span>, d, <span class="string">'kw ='</span>, kw)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 函数调用</span></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>) </span><br><span class="line"><span class="comment"># a = 1 b = 2 c = 0 args = () kw = &#123;&#125;</span></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># a = 1 b = 2 c = 3 args = () kw = &#123;&#125;</span></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"><span class="comment"># a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;&#125;</span></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, x=<span class="number">99</span>)</span><br><span class="line"><span class="comment"># a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;'x': 99&#125;</span></span><br><span class="line"></span><br><span class="line">f2(<span class="number">1</span>, <span class="number">2</span>, age=<span class="number">99</span>, ext=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># a = 1 b = 2 c = 0 age = 99 kw = &#123;'ext': None&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最神奇的是通过一个 tuple 和 dict，你也可以调用上述函数</span></span><br><span class="line">args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">kw = &#123;<span class="string">'age'</span>: <span class="number">99</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br><span class="line">f1(*args, **kw)</span><br><span class="line"><span class="comment"># a = 1 b = 2 c = 3 args = (4,) kw = &#123;'age': 99, 'x': '#'&#125;</span></span><br><span class="line"></span><br><span class="line">args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">kw = &#123;<span class="string">'age'</span>: <span class="number">88</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br><span class="line">f2(*args, **kw)</span><br><span class="line"><span class="comment"># a = 1 b = 2 c = 3 age = 88 kw = &#123;'x': '#'&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="生成器">生成器</h4>
<p><strong>1. 生成器</strong>： 一遍循环一遍计算的机制称为生成器：generator</p>
<ul>
<li>创建生成器</li>
</ul>
<p>（1）只要把一个列表生成式的 [] 改成 ()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))  <span class="comment"># ①生成器</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>
<ul>
<li>将 [] 改为 () 的生成器</li>
<li>带 yield 函数的 生成器函数</li>
</ul>
<p>generator 保存的是算法，每次调用 next()，就计算出 g 的下一个元素的值，遇到 <code>yield</code> 语句返回，再次执行时，从上次放回的 <code>yield</code> 语句处继续执行。一般创建了一个generator后，基本不会使用next()，而是通过for循环来迭代（<strong>Python的for循环本质上就是通过不断调用next()函数实现的</strong>）</p>
<blockquote>
<p>如果直接使用next() 函数不断调用并返回下一个值，直到没有数据时抛出 StopIteration 错误。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始斐波拉契数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        print(b, end=<span class="string">' '</span>)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将fib函数变为 ② 生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibII</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b     <span class="comment"># 只做了这一处修改</span></span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 原始fib</span></span><br><span class="line">    fib(<span class="number">6</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成器版fib</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fibII(<span class="number">6</span>):</span><br><span class="line">        print(i, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>普通函数：调用直接返回结果</li>
<li>生成器generator函数：调用它实际返回一个generator对象</li>
</ul>
<h4 id="迭代器">迭代器</h4>
<h5 id="可迭代对象-iterable">（1）可迭代对象 Iterable</h5>
<ul>
<li>集合数据类型：list、tuple、dict、set、str</li>
<li>generator：生成器 和 带 yield 的 generator 函数</li>
</ul>
<p>使用 <code>isinstance()</code> 判断一个对象是否是 Iterable 对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line">isinstance([], Iterable) <span class="comment"># True</span></span><br><span class="line">isinstance(&#123;&#125;, Iterable) <span class="comment"># True</span></span><br><span class="line">isinstance(<span class="string">'abc'</span>, Iterable) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<h5 id="迭代器-iterator">（2）迭代器 Iterator</h5>
<p>可以被 next() 函数调用并不断返回下一个值的对象称为迭代器 Iterator.</p>
<p>可以使用 isinstance()判断一个对象是否是 Iterator 对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line">isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterator) <span class="comment"># True</span></span><br><span class="line">isinstance([], Iterator) <span class="comment"># False</span></span><br><span class="line">isinstance(&#123;&#125;, Iterator) <span class="comment"># False</span></span><br><span class="line">isinstance(<span class="string">'abc'</span>, Iterator) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>生成器都是 Iterator 对象，但 list、 dict、 str 虽然是 Iterable，却不是 Iterator</p>
<p>把 list、 dict、 str 等 Iterable 变成 Iterator 可以使用 iter()函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isinstance(iter([]), Iterator) <span class="comment"># True</span></span><br><span class="line">isinstance(iter(<span class="string">'abc'</span>), Iterator) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<h4 id="装饰器">装饰器</h4>
<p>装饰器本质是一个闭包函数，实现的功能是：在不修改原函数及调用方式的情况下对原函数进行功能扩展。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wraper</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'执行函数前扩展的内容'</span>)</span><br><span class="line">        ret = func(*args, **kw)</span><br><span class="line">        print(<span class="string">'执行函数后扩展的内容'</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@wraper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    print(<span class="string">'我叫%s，今年%s岁'</span> % (name, age))</span><br><span class="line"></span><br><span class="line">index(<span class="string">'小明'</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行函数前扩展的内容</span></span><br><span class="line"><span class="comment"># 我叫小明，今年25岁</span></span><br><span class="line"><span class="comment"># 执行函数后扩展的内容</span></span><br></pre></td></tr></table></figure>
<h4 id="闭包">闭包</h4>
<p>如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包(closure)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>
<p>inner(y)就是这个内部函数，对在外部作用域（但不是在全局作用域）的变量进行引用：x就是被引用的变量，x在外部作用域outer里面，但不在全局作用域里，则这个内部函数inner就是一个闭包。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = outer(<span class="number">2</span>)</span><br><span class="line">print(<span class="string">'function:'</span>,a) </span><br><span class="line">print(<span class="string">'result:'</span>,a(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># function: &lt;function outer.&lt;locals&gt;.inner at 0x7f61190e8e18&gt;</span></span><br><span class="line"><span class="comment"># result: 5</span></span><br></pre></td></tr></table></figure>
<p>这里a就是inner函数，是一个闭包。</p>
<p>注意：</p>
<ul>
<li>闭包无法修改外部函数的局部变量</li>
<li>闭包无法直接访问外部函数的局部变量</li>
</ul>
<p>作用：</p>
<ul>
<li>闭包也具有提高代码可复用性的作用。</li>
</ul>
<h4 id="匿名函数-lambda">匿名函数 lambda</h4>
<p>lambda函数省去了函数定义，不用担心函数名冲突。匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list(map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line"><span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>
<p>其中 匿名函数 <code>lambda x: x * x</code> 实际上就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> x * x</span><br></pre></td></tr></table></figure>
<h4 id="type-与-isinstance-区别">type 与 isinstance 区别</h4>
<p>相同点：都可以用来判断对象的类型</p>
<p>不同点：</p>
<ul>
<li>type() 不会认为子类是一种父类类型</li>
<li>isinstance() 会认为子类是一种父类类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">isinstance(A(), A)    <span class="comment"># True</span></span><br><span class="line">type(A()) == A        <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">isinstance(B(), A)    <span class="comment"># True</span></span><br><span class="line">type(B()) == A        <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="python中的继承">—-Python中的继承</h4>
<p>当一个类继承自另一个类，它就被称为一个子类/派生类，继承自父类/基类/超类。它会继承/获取所有类成员（属性和方法）。</p>
<p>继承能让我们重新使用代码，也能更容易的创建和维护应用。Python支持如下种类的继承：</p>
<ul>
<li>单继承：一个类继承自单个基类</li>
<li>多继承：一个类继承自多个基类</li>
<li>多级继承：一个类继承自单个基类，后者则继承自另一个基类</li>
<li>分层继承：多个类继承自单个基类</li>
<li>混合继承：两种或多种类型继承的混合更多关于继承的内容，参见：</li>
</ul>
<blockquote>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fdata-flair.training%2Fblogs%2Fpython-inheritance%2F" target="_blank" rel="noopener">Python继承教程</a></p>
</blockquote>
<h4 id="进程-线程-协程">进程 / 线程 / 协程</h4>
<p>（1）<strong>进程</strong>：是系统资源分配和调度的一个独立单位，每个进程都有自己的内存空间，占用内存资源比较多，上下文切换开销大，比较稳定和安全。</p>
<p>（2）<strong>线程</strong>：【同步机制】CPU处理器调度的基本单位，进程中的一个执行单位可调度的实体，占用系统资源很少，同一个进程中的多个线程可以共享全局变量，通信主要是共享进程内存，资源开销很小，不够稳定，易丢失数据。</p>
<p>（3）<strong>协程</strong>：【异步机制】调度由用户控制，更加轻量级的线程，拥有自己的寄存器和上下文栈，开销小，切换上下文迅速。</p>
<h4 id="gil锁">GIL锁</h4>
<p>GIL 是python的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。</p>
<p>多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大</p>
<h4 id="内存管理">内存管理</h4>
<p>Python有一个私有堆空间来保存所有的对象和数据结构。作为开发者，我们无法访问它，是解释器在管理它。但是有了核心API后，我们可以访问一些工具。Python内存管理器控制内存分配。</p>
<p>另外，内置垃圾回收器会回收使用所有的未使用内存，所以使其适用于堆空间。</p>
<h4 id="引用计数机制">引用计数机制</h4>
<blockquote>
<p><strong>python垃圾回收</strong>主要以<strong><code>引用计数为主</code>，<code>标记-清除</code>和<code>分代清除</code></strong>为辅的机制，其中标记-清除和分代回收主要是为了<u>处理循环引用的难题</u>。</p>
</blockquote>
<p><strong>1. 引用计数</strong></p>
<p>当有1个变量保存了对象的引用时，此对象的引用计数就会加1。当使用del删除变量指向的对象时，引用计数就会减1，当引用计数为0时，此时会真的把对象进行删除。</p>
<p>优点:</p>
<ol style="list-style-type: decimal">
<li>简单</li>
<li>实时性</li>
</ol>
<p>缺点:</p>
<ol style="list-style-type: decimal">
<li>维护引用计数消耗资源</li>
<li>循环引用</li>
</ol>
<p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p>
<p><strong>2. 标记-清除机制</strong></p>
<p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p>
<p><strong>3. 分代技术</strong></p>
<p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p>
<p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。</p>
<p>举例： 当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。</p>
<h4 id="当退出python时是否释放全部内存">当退出Python时，是否释放全部内存？</h4>
<p>答案是No。循环引用其它对象或引用自全局命名空间的对象的模块，在Python退出时并非完全释放。另外，也不会释放C库保留的内存部分。</p>
<h4 id="flask">Flask</h4>
<p>Flask是Python编写的一款轻量级Web应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2。Flask使用 BSD 授权。其中两个环境依赖是Werkzeug和jinja2，这意味着它不需要依赖外部库。正因如此，我们将其称为轻量级框架。</p>
<p>Flask会话使用签名cookie让用户查看和修改会话内容。它会记录从一个请求到另一个请求的信息。不过，要想修改会话，用户必须有密钥Flask.secret_key。</p>
<h4 id="文件操作-1">文件操作</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读文件</span></span><br><span class="line"><span class="comment"># r: 只读方式打开文件</span></span><br><span class="line"><span class="comment"># rb：二进制格式打开文件只读</span></span><br><span class="line"><span class="comment"># r+: 打开文件用于读写，不存在则会创建该文件。文件指针在文件的开头</span></span><br><span class="line"><span class="comment"># rb+: 以二进制格式打开文件用于读写，不存在则会创建该文件。文件指针在文件的开头</span></span><br><span class="line">f = open(<span class="string">'./file.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">print(f.read())</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写文件</span></span><br><span class="line"><span class="comment"># w : 打开文件，只写（覆盖写）</span></span><br><span class="line"><span class="comment"># wb：以二进制格式打开文件，只写（覆盖）</span></span><br><span class="line"><span class="comment"># w+: 打开文件用于读写（覆盖写），不存在则会创建该文件</span></span><br><span class="line"><span class="comment"># wb+: 以二进制格式打开文件，读写（覆盖写），不存在则会创建该文件</span></span><br><span class="line">f = open(<span class="string">'./file.txt'</span>, <span class="string">'w+'</span>)</span><br><span class="line">f.write(<span class="string">'Hello, world!'</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># a: 打开文件并再文件末尾追加，文件不存在则创建新的文件</span></span><br><span class="line"><span class="comment"># ab: 二进制方式打开文件并在末尾追加</span></span><br><span class="line"><span class="comment"># a+： 打开文件用于读写，追加</span></span><br><span class="line"><span class="comment"># ab+: 以二进制格式打开文件并在末尾追加</span></span><br><span class="line">f = open(<span class="string">'./file.txt'</span>, <span class="string">'a+'</span>)</span><br><span class="line">f.write(<span class="string">'你好'</span>)   <span class="comment"># 写入字符串</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上都没有做异常处理，由于文件读写时，会产生IOError，以上一旦出错，后面的f.close()就不会调用。</span></span><br><span class="line"><span class="comment"># 所以我们为了要保证文件正确地关闭，可以使用try...finally来实现</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'./file.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> f:</span><br><span class="line">            f.close()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 每次都这样写比较繁琐，Python引入了with语句来自动帮我们调用close()方法</span></span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">'./file.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="comment"># print(f.read())         # read()        读取文件所有内容</span></span><br><span class="line">                <span class="comment"># print(f.readline())     # readline()    读取一行内容</span></span><br><span class="line">                print(f.read(<span class="number">5</span>))        <span class="comment"># read(size)    读取5个字节的字符串</span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>如何自己实现迭代器</li>
<li>Python的内存回收机制</li>
<li>使用迭代器遍历和非迭代器遍历的区别</li>
</ul>
<hr>
<h3 id="计算机网络">计算机网络</h3>
<h4 id="tcp-和-udp-的特点">TCP 和 UDP 的特点</h4>
<ul>
<li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li>
</ul>
<h4 id="tcp-的三次握手">TCP 的三次握手</h4>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/pics/e92d0ebc-7d46-413b-aec1-34a39602f787.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img"></a></p>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<p><strong>三次握手的原因</strong></p>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<h4 id="tcp-的四次挥手">TCP 的四次挥手</h4>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/pics/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="img"></a></p>
<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li>A 发送连接释放报文，FIN=1。</li>
<li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li>
<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<hr>
<h3 id="linux">Linux</h3>
<h4 id="常用命令">常用命令</h4>
<table>
<thead>
<tr class="header">
<th>常用Linux命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cd</td>
<td>进入目录</td>
</tr>
<tr class="even">
<td>cp</td>
<td>拷贝文件</td>
</tr>
<tr class="odd">
<td>mv</td>
<td>移动文件</td>
</tr>
<tr class="even">
<td>rm</td>
<td>删除文件</td>
</tr>
<tr class="odd">
<td>ls</td>
<td>查看文件</td>
</tr>
<tr class="even">
<td>ls -l -a</td>
<td>查看文件目录详情</td>
</tr>
<tr class="odd">
<td>tree -L 2</td>
<td>以树形结构查看目录</td>
</tr>
<tr class="even">
<td>grep -n -H -R</td>
<td>递归查找包含某一条语句的文件，并显示行号</td>
</tr>
<tr class="odd">
<td>find / -name test</td>
<td>查找 / 目录下名为test的文件</td>
</tr>
<tr class="even">
<td>locate test</td>
<td>查找和 test 相关的文件</td>
</tr>
<tr class="odd">
<td>cat</td>
<td>查看文本文件内容</td>
</tr>
<tr class="even">
<td>chown</td>
<td>改变文件的所有者</td>
</tr>
<tr class="odd">
<td>chmod</td>
<td>改变文件的权限</td>
</tr>
<tr class="even">
<td>mkdir</td>
<td>新建文件夹</td>
</tr>
<tr class="odd">
<td><code>ls -l | grep '^-' | wc -l</code></td>
<td>统计某文件夹下文件的个数</td>
</tr>
<tr class="even">
<td><code>ls -l | grep '^d' | wc -l</code></td>
<td>统计某文件夹下目录的个数</td>
</tr>
<tr class="odd">
<td><code>ls -lR | grep '^d' | wc -l</code></td>
<td>统计文件夹下文件的个数，包括子文件夹里的</td>
</tr>
<tr class="even">
<td>jobs -l</td>
<td>查看后台进程</td>
</tr>
<tr class="odd">
<td>bg %1</td>
<td>将后台进程1切换到当前运行</td>
</tr>
<tr class="even">
<td>kill %1</td>
<td>杀死进程好为1的进程</td>
</tr>
<tr class="odd">
<td>top</td>
<td>显示系统中各个进程的资源占用状况</td>
</tr>
<tr class="even">
<td>df</td>
<td>查看磁盘空间</td>
</tr>
<tr class="odd">
<td>df -hl</td>
<td>查看磁盘剩余空间</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="gbd">gbd</h4>
<table>
<colgroup>
<col width="33%">
<col width="33%">
<col width="33%">
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="http://man.linuxde.net/file" target="_blank" rel="noopener">file</a> <文件名></文件名></td>
<td>加载被调试的可执行程序文件。因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。</td>
<td>(gdb) file gdb-sample</td>
</tr>
<tr class="even">
<td>r</td>
<td>Run的简写，运行被调试的程序。如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。</td>
<td>(gdb) r</td>
</tr>
<tr class="odd">
<td>c</td>
<td>Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。</td>
<td>(gdb) c</td>
</tr>
<tr class="even">
<td>b <行号>b <函数名称>b <em><函数名称>b </函数名称></em><代码地址> d [编号]</代码地址></函数名称></行号></td>
<td>b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。 d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。</td>
<td>(gdb) b 8(gdb) b main(gdb) b <em>main(gdb) b </em>0x804835c (gdb) d</td>
</tr>
<tr class="odd">
<td>s, n</td>
<td>s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数；n: 执行一行源程序代码，此行代码中的函数调用也一并执行。 s 相当于其它调试器中的“Step Into (单步跟踪进入)”；n 相当于其它调试器中的“Step Over (单步跟踪)”。 这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。</td>
<td>(gdb) s(gdb) n</td>
</tr>
<tr class="even">
<td>si, ni</td>
<td>si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。</td>
<td>(gdb) si(gdb) ni</td>
</tr>
<tr class="odd">
<td>p <变量名称></变量名称></td>
<td>Print的简写，显示指定变量（临时变量或全局变量）的值。</td>
<td>(gdb) p i(gdb) p nGlobalVar</td>
</tr>
<tr class="even">
<td>display … undisplay <编号></编号></td>
<td>display，设置程序中断后欲显示的数据及其格式。例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令“display /i $pc”其中 $pc 代表当前汇编指令，/i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。 undispaly，取消先前的display设置，编号从1开始递增。</td>
<td>(gdb) display /i $pc (gdb) undisplay 1</td>
</tr>
<tr class="odd">
<td>i</td>
<td><a href="http://man.linuxde.net/info" target="_blank" rel="noopener">info</a>的简写，用于显示各类信息，详情请查阅“<a href="http://man.linuxde.net/help" target="_blank" rel="noopener">help</a> i”。</td>
<td>(gdb) i r</td>
</tr>
<tr class="even">
<td>q</td>
<td>Quit的简写，退出GDB调试环境。</td>
<td>(gdb) q</td>
</tr>
<tr class="odd">
<td>help [命令名称]</td>
<td>GDB帮助命令，提供对GDB名种命令的解释说明。如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Reference：<a href="http://man.linuxde.net/gdb" target="_blank" rel="noopener">gdb入门</a></p>
</blockquote>
<hr>
<h3 id="git">Git</h3>
<h4 id="常用命令-1">常用命令</h4>
<table>
<thead>
<tr class="header">
<th align="left">git 常用命令</th>
<th>命令功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">git init</td>
<td>初始化</td>
</tr>
<tr class="even">
<td align="left">git add</td>
<td>添加到版本库中的暂存区</td>
</tr>
<tr class="odd">
<td align="left">git commit</td>
<td>把暂存区的内容提交到当前分支</td>
</tr>
<tr class="even">
<td align="left">git checkout –file</td>
<td>直接丢弃工作区的修改</td>
</tr>
<tr class="odd">
<td align="left"><strong>git reset</strong> –hard HEAD^</td>
<td>回退到上一个版本</td>
</tr>
<tr class="even">
<td align="left">git reset –herd 362816</td>
<td>回退到指定版本</td>
</tr>
<tr class="odd">
<td align="left">git log</td>
<td>查看版本库信息</td>
</tr>
<tr class="even">
<td align="left">git reflog</td>
<td>查看本地记录的与版本库相关的每一条命令</td>
</tr>
<tr class="odd">
<td align="left">git status</td>
<td>查看工作区的状态</td>
</tr>
<tr class="even">
<td align="left">git diff</td>
<td>查看修改内容</td>
</tr>
<tr class="odd">
<td align="left">git remote add origin</td>
<td>添加远程仓库</td>
</tr>
<tr class="even">
<td align="left">git push -u origin master</td>
<td>将本地库内容推送到远程仓库（第一次推送加-u）</td>
</tr>
<tr class="odd">
<td align="left">git push origin master</td>
<td>推送至主分支</td>
</tr>
<tr class="even">
<td align="left">git push origin dev</td>
<td>推送至dev分支</td>
</tr>
<tr class="odd">
<td align="left">git clone</td>
<td>从远程仓库克隆</td>
</tr>
<tr class="even">
<td align="left">git branch name</td>
<td>创建name分支</td>
</tr>
<tr class="odd">
<td align="left">git checkout name</td>
<td>切换至name分支</td>
</tr>
<tr class="even">
<td align="left">git branch -b name</td>
<td>创建并切换至name分支</td>
</tr>
<tr class="odd">
<td align="left">git branch</td>
<td>查看当前分支</td>
</tr>
<tr class="even">
<td align="left">git branch -d name</td>
<td>删除分支</td>
</tr>
<tr class="odd">
<td align="left">git branch -D name</td>
<td>强行删除分支</td>
</tr>
<tr class="even">
<td align="left"><strong>git merge name</strong></td>
<td>将name分支合并到master分支上</td>
</tr>
<tr class="odd">
<td align="left"><strong>git rebase</strong></td>
<td></td>
</tr>
<tr class="even">
<td align="left">git remote</td>
<td>查看远程库信息</td>
</tr>
<tr class="odd">
<td align="left">git remote -v</td>
<td>查看远程库详细信息</td>
</tr>
<tr class="even">
<td align="left">git log –graph</td>
<td>查看分支合并图</td>
</tr>
<tr class="odd">
<td align="left">git pull</td>
<td>将远程库最新提交抓取下来</td>
</tr>
<tr class="even">
<td align="left"></td>
<td></td>
</tr>
<tr class="odd">
<td align="left">git tag v1.0</td>
<td>创建名为v1.0的标签</td>
</tr>
<tr class="even">
<td align="left">git tag</td>
<td>查看所有标签</td>
</tr>
<tr class="odd">
<td align="left">git tag v0.9 0abc</td>
<td>为指定commit提交打标签</td>
</tr>
<tr class="even">
<td align="left">git show v0.9</td>
<td>查看指定标签信息</td>
</tr>
<tr class="odd">
<td align="left">git tag -d v0.1</td>
<td>删除标签</td>
</tr>
<tr class="even">
<td align="left">git push origin v1.0</td>
<td>推送某一个标签到远程</td>
</tr>
<tr class="odd">
<td align="left">git push origin –tags</td>
<td>一次性推送全部尚未推送到远程的本地标签</td>
</tr>
<tr class="even">
<td align="left"></td>
<td></td>
</tr>
<tr class="odd">
<td align="left">git stash</td>
<td>保存当前工作现场</td>
</tr>
<tr class="even">
<td align="left">git stash list</td>
<td>查看工作现场</td>
</tr>
<tr class="odd">
<td align="left">git stash pop</td>
<td>回到工作现场</td>
</tr>
<tr class="even">
<td align="left"></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>撤销修改</strong></li>
</ul>
<div class="figure">
<img src="/2018/04/07/Interview-preparation-of-cpp/撤销修改.png">

</div>
<ul>
<li><strong>多人协作</strong></li>
</ul>
<div class="figure">
<img src="/2018/04/07/Interview-preparation-of-cpp/git.png">

</div>
<h4 id="git-pull-时发生冲突">git pull 时发生冲突</h4>
<ol style="list-style-type: decimal">
<li>先将本地修改存储起来</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<ol start="2" style="list-style-type: decimal">
<li>暂存了本地修改之后，就可以pull了</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<ol start="3" style="list-style-type: decimal">
<li>还原暂存的内容</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
<ol start="4" style="list-style-type: decimal">
<li>如果有冲突就本地手动解决冲突，然后再提交即可。</li>
</ol>
<h4 id="修复bug">修复bug</h4>
<p>通过创建新的bug分支进行修复，然后合并，最后删除。</p>
<p>当手头工作没有完成时，先把工作现场 git stash 一下，然后再修复bug，修复后，再git stash pop，回到工作现场。</p>
<h4 id="git-merge-和-git-rebase-区别">git merge 和 git rebase 区别</h4>
<blockquote>
<p><strong>git merge使用方法</strong></p>
</blockquote>
<p>比如将分支 <code>feature</code> 合并到分支 <code>master</code>，那么只需执行如下两步即可：</p>
<ol style="list-style-type: decimal">
<li>将分支切换到 <code>master</code> 上去：<code>git checkout master</code></li>
<li>将分支 <code>feature</code> 合并到当前分支（即 <code>master</code> 分支）上：<code>git merge feature</code></li>
</ol>
<div class="figure">
<img src="/2018/04/07/Interview-preparation-of-cpp/git_merge.png">

</div>
<p><strong>特点：</strong></p>
<ol style="list-style-type: decimal">
<li>自动创建一个新的合并的历史记录commit</li>
<li>如果合并的时候遇到冲突，仅需要修改后重新commit，合并后的所有 <code>commit</code> 会按照提交时间从旧到新排列</li>
<li>所有的过程信息更多，可能会提高之后查找问题的难度</li>
</ol>
<p><strong>优点：</strong></p>
<ol style="list-style-type: decimal">
<li>记录了真实的commit情况，包括每个分支的详情</li>
</ol>
<blockquote>
<p><strong>git rebase 合并操作</strong></p>
</blockquote>
<p>与 <code>git merge</code> 一致，<code>git rebase</code> 的目的也是将一个分支的更改并入到另外一个分支中去。</p>
<div class="figure">
<img src="/2018/04/07/Interview-preparation-of-cpp/git_rebase.png">

</div>
<p>主要特点是：</p>
<ol style="list-style-type: decimal">
<li>得到更简洁的项目历史，去掉了merge commit</li>
<li>会合并之前的commit历史</li>
<li>没有多余的合并历史的记录，且合并后的 <code>commit</code> 顺序不一定按照 <code>commit</code> 的提交时间排列</li>
<li>改变当前分支从 <code>master</code> 上拉出分支的位置</li>
<li>如果合并出现代码问题不容易定位</li>
</ol>
<p>合并时如果出现冲突需要按照如下步骤解决</p>
<ul>
<li>修改冲突部分</li>
<li>git add</li>
<li><code>git rebase --continue</code></li>
<li>（如果第三步无效可以执行 <code>git rebase --skip</code>）</li>
</ul>
<blockquote>
<p><strong>总结</strong></p>
</blockquote>
<p>（1）当需要保留详细的合并信息的时候建议使用<code>git merge</code>，特别是需要将分支合并进入<code>master</code>分支时。</p>
<p>（2）如果你想要一个干净的，没有merge commit的线性历史树，那么你应该选择git rebase。比如当发现自己修改某个功能时，频繁进行了<code>git commit</code>提交时，发现其实过多的提交信息没有必要时，可以尝试<code>git rebase</code>。</p>
<blockquote>
<p>Reference: <a href="https://juejin.im/post/5af26c4d5188256728605809" target="_blank" rel="noopener">Git知识</a></p>
</blockquote>
<hr>
<h3 id="reference">Reference</h3>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjcxMjQxNg==&amp;mid=2247490302&amp;idx=2&amp;sn=65dd20ad57f62a1f9f6015d7106afc2c&amp;pass_ticket=YQUuRNDSktmCTNEQiVxLaq%2FsjKeEZe7UAyeMwFVb%2BLcajMRRSXFXmPDHvTKr9pef" target="_blank" rel="noopener">常见C++笔试面试题整理</a></li>
<li><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1564925799&amp;ver=1770&amp;signature=ongzKTcftM2gPmBeFLvCxQBsAUwUXldq*Q2WH4oqXzppRIHM8gBKAB6NQPi8W83g7emTtiqesaOIcBMVfF7gXy2aqhCuv3MKmDAKHhqIPuTboLuab9XUV8dS4kuhvlzf&amp;new=1" target="_blank" rel="noopener">C++面试总结</a></li>
<li><a href="https://github.com/huihut/interview#-cc" target="_blank" rel="noopener">huihut/interview</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/54430650" target="_blank" rel="noopener">110道python面试题(真题)</a>x`</li>
</ul>
</body>
</html>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag">#C</a>
          
            <a href="/tags/算法/" rel="tag">#算法</a>
          
            <a href="/tags/数据结构/" rel="tag">#数据结构</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/07/Try-your-best!You-will-find-the-job/" rel="prev">
                <i class="fa fa-chevron-left"></i> 加油！一定能找到好工作！
              </a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/07/Ubuntu-common-commands/" rel="next">
                Ubuntu常用命令 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
          </div>
        
      

        
          
  
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
      
      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table Of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview" sidebar-panel >
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.jpg" alt="SmileLingyong" itemprop="image"/>
          <p class="site-author-name" itemprop="name">SmileLingyong</p>
        </div>
        <p class="site-description motion-element" itemprop="description">向上，向阳！</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">32</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">categories</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">tags</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="smilelingyong@gmail.com" target="_blank">
                  <i class="fa fa-e-mail"></i> E-Mail
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/SmileLingyong" target="_blank">
                  <i class="fa fa-github"></i> Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://blog.csdn.net/forever__1234" target="_blank">
                  <i class="fa fa-csdn"></i> CSDN
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#c"><span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#c-数据类型取值范围精度"><span class="nav-text">C 数据类型/取值范围/精度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c中的基本数据类型及派生类型"><span class="nav-text">C++中的基本数据类型及派生类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#typdef-和-define区别"><span class="nav-text">typdef 和 define区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#define-和-const-的区别"><span class="nav-text">define 和 const 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const-作用"><span class="nav-text">const 作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static"><span class="nav-text">static</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this-指针"><span class="nav-text">this 指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inline-内联函数"><span class="nav-text">inline 内联函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚函数virtual可以是内联函数inline吗"><span class="nav-text">虚函数（virtual）可以是内联函数（inline）吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile"><span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#explicit"><span class="nav-text">explicit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#auto-和-decltype"><span class="nav-text">auto 和 decltype</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#assert"><span class="nav-text">assert()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sizeof"><span class="nav-text">sizeof()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pragma-packn"><span class="nav-text">#pragma pack(n)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#位域"><span class="nav-text">位域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extern-c"><span class="nav-text">extern “C”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-中-struct-和-class"><span class="nav-text">C++ 中 struct 和 class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结构体-struct-和-共同体-union联合的区别"><span class="nav-text">结构体 struct 和 共同体 union（联合）的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结构体为什么要内存对齐呢"><span class="nav-text">结构体为什么要内存对齐呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义和声明的区别"><span class="nav-text">定义和声明的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c和c的区别"><span class="nav-text">C和C++的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c中指针和引用的区别"><span class="nav-text">C++中指针和引用的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用作为函数参数以及返回值的好处"><span class="nav-text">引用作为函数参数以及返回值的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#左值引用"><span class="nav-text">左值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#右值引用"><span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用折叠"><span class="nav-text">引用折叠</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#范围解析运算符"><span class="nav-text">：：范围解析运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section"><span class="nav-text">———-</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承中的特点"><span class="nav-text">继承中的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重载overload覆盖重写override隐藏重定义overwrite这三者之间的区别"><span class="nav-text">重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态-虚函数-纯虚函数"><span class="nav-text">**多态， 虚函数， 纯虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚函数-与-纯虚函数"><span class="nav-text">虚函数 与 纯虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚函数是怎么实现的"><span class="nav-text">虚函数是怎么实现的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数为什么一般不定义为虚函数而析构函数一般写成虚函数的原因"><span class="nav-text">构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数中是否可以调用虚函数"><span class="nav-text">构造函数中是否可以调用虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚函数指针虚函数表"><span class="nav-text">虚函数指针、虚函数表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承中子类构造函数和析构函数调用顺序"><span class="nav-text">继承中，子类构造函数和析构函数调用顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子类析构时要调用父类的析构函数吗"><span class="nav-text">子类析构时，要调用父类的析构函数吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚继承"><span class="nav-text">虚继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚继承-与-虚函数的联系与区别"><span class="nav-text">虚继承 与 虚函数的联系与区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模板类成员模板虚函数"><span class="nav-text">模板类、成员模板、虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象类接口类聚合类"><span class="nav-text">抽象类、接口类、聚合类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#friend-友元类和友元函数"><span class="nav-text">friend 友元类和友元函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#友元函数和友元类"><span class="nav-text">友元函数和友元类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c的内存管理"><span class="nav-text">**C++的内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈和堆的区别"><span class="nav-text">栈和堆的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c中内存泄漏的几种情况"><span class="nav-text">C++中内存泄漏的几种情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈溢出的原因以及解决方法"><span class="nav-text">栈溢出的原因以及解决方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是野指针"><span class="nav-text">什么是野指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newdeletemallocfree之间的关系"><span class="nav-text">new、delete、malloc、free之间的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#既然有了mallocfreec中为什么还需要newdelete呢"><span class="nav-text">既然有了malloc/free，C++中为什么还需要new/delete呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete和delete的区别"><span class="nav-text">delete和delete[]的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete-this-合法吗"><span class="nav-text">delete this 合法吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section-1"><span class="nav-text">——</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stl库用过吗常见的stl容器有哪些算法用过几个"><span class="nav-text">STL库用过吗？常见的STL容器有哪些？算法用过几个？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector-实现机制"><span class="nav-text">vector 实现机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c中vector和list的区别"><span class="nav-text">C++中vector和list的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c常见容器的时间复杂度"><span class="nav-text">C++常见容器的时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#map-和-set-的原理"><span class="nav-text">map 和 set 的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#map-和-unordered_map-区别"><span class="nav-text">map 和 unordered_map 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c包含的新特性"><span class="nav-text">C++包含的新特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#智能指针"><span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用的智能指针"><span class="nav-text">常用的智能指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#智能指针的作用"><span class="nav-text">智能指针的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#强制类型转换运算符"><span class="nav-text">强制类型转换运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c文件编译与执行的四个阶段"><span class="nav-text">C++文件编译与执行的四个阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gcc编译的四个步骤-以最简单的hello.c为例子"><span class="nav-text">gcc编译的四个步骤, 以最简单的hello.c为例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gcc-和-g的区别"><span class="nav-text">gcc 和 g++的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section-2"><span class="nav-text">——</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拷贝构造函数"><span class="nav-text">拷贝构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调用拷贝构造函数三种情况"><span class="nav-text">调用拷贝构造函数（三种情况）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#浅拷贝和深拷贝的区别"><span class="nav-text">浅拷贝和深拷贝的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#null-和-nullptr-区别"><span class="nav-text">NULL 和 nullptr 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda-捕获对象的实现待补充"><span class="nav-text">lambda 捕获对象的实现（待补充）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆定义的头文件"><span class="nav-text">堆定义的头文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模板类"><span class="nav-text">模板类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#long-long根以前的c-版本有什么区别"><span class="nav-text">long long根以前的C++ 版本有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#includefile.h-include-file.h-的区别"><span class="nav-text">#include&lt;file.h&gt; #include “file.h” 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件操作"><span class="nav-text">文件操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他问题待整理"><span class="nav-text">**其他问题待整理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统"><span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一进程与线程"><span class="nav-text">一、进程与线程—–</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程通信与同步"><span class="nav-text">进程通信与同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程之间的通信方式"><span class="nav-text">进程之间的通信方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程之间的同步方式不是很清晰"><span class="nav-text">进程之间的同步方式(不是很清晰)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section-3"><span class="nav-text">——</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程之间的通信同步方式"><span class="nav-text">线程之间的通信/同步方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全和线程不安全"><span class="nav-text">线程安全和线程不安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程线程的私有共享资源"><span class="nav-text">进程/线程的私有、共享资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多进程与多线程-对比"><span class="nav-text">多进程与多线程 对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux-内核的同步方式"><span class="nav-text">Linux 内核的同步方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁"><span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程状态"><span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程调度算法"><span class="nav-text">进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#批处理系统"><span class="nav-text">1. 批处理系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#交互式系统"><span class="nav-text">2. 交互式系统</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞与非阻塞"><span class="nav-text">阻塞与非阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发并行"><span class="nav-text">并发、并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二内存管理"><span class="nav-text">二、内存管理—–</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#物理地址和虚拟地址"><span class="nav-text">物理地址和虚拟地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟内存"><span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分页系统地址映射"><span class="nav-text">分页系统地址映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页面置换算法"><span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#最佳opt"><span class="nav-text">1. 最佳(OPT)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最近最久未使用lru"><span class="nav-text">2. 最近最久未使用(LRU)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最近未使用nru"><span class="nav-text">3. 最近未使用(NRU)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#先进先出fifo"><span class="nav-text">4. 先进先出(FIFO)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第二次机会算法"><span class="nav-text">5. 第二次机会算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#时钟"><span class="nav-text">6. 时钟</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分段"><span class="nav-text">分段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#段页式"><span class="nav-text">段页式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分页与分段的比较"><span class="nav-text">分页与分段的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三设备管理"><span class="nav-text">三、设备管理—–</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘结构"><span class="nav-text">磁盘结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘调度算法"><span class="nav-text">磁盘调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#先来先服务"><span class="nav-text">1. 先来先服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最短寻道时间优先"><span class="nav-text">2. 最短寻道时间优先</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#电梯算法"><span class="nav-text">3. 电梯算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python"><span class="nav-text">Python</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常用函数"><span class="nav-text">常用函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sort-和-sorted-区别"><span class="nav-text">sort() 和 sorted() 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#random随机数随机字符串"><span class="nav-text">random随机数/随机字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三元运算"><span class="nav-text">三元运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用的python模块"><span class="nav-text">常用的Python模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模块-和-包"><span class="nav-text">模块 和 包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#几种魔法方法"><span class="nav-text">几种魔法方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单利模式"><span class="nav-text">单利模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#深拷贝和浅拷贝"><span class="nav-text">深拷贝和浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#range-和-xrange-区别"><span class="nav-text">range 和 xrange 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内建数据类型"><span class="nav-text">内建数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list-和-tuple-区别"><span class="nav-text">list 和 tuple 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列表元组集合字典的区别"><span class="nav-text">列表、元组、集合、字典的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#列表元组转其他"><span class="nav-text">列表元组转其他</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字典转其他"><span class="nav-text">字典转其他</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符串转其他"><span class="nav-text">字符串转其他</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collections-模块"><span class="nav-text">collections 模块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#defaultdict"><span class="nav-text">defaultdict</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ordereddict"><span class="nav-text">orderedDict</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#deque"><span class="nav-text">deque</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#counter"><span class="nav-text">Counter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#namedtuple"><span class="nav-text">namedtuple</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#heapq"><span class="nav-text">heapq</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list删除元素"><span class="nav-text">list删除元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建二维数组"><span class="nav-text">创建二维数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#下划线命名"><span class="nav-text">下划线命名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数参数"><span class="nav-text">！函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成器"><span class="nav-text">生成器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器"><span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#可迭代对象-iterable"><span class="nav-text">（1）可迭代对象 Iterable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#迭代器-iterator"><span class="nav-text">（2）迭代器 Iterator</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装饰器"><span class="nav-text">装饰器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#闭包"><span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#匿名函数-lambda"><span class="nav-text">匿名函数 lambda</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#type-与-isinstance-区别"><span class="nav-text">type 与 isinstance 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#python中的继承"><span class="nav-text">—-Python中的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程-线程-协程"><span class="nav-text">进程 / 线程 / 协程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gil锁"><span class="nav-text">GIL锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存管理"><span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用计数机制"><span class="nav-text">引用计数机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#当退出python时是否释放全部内存"><span class="nav-text">当退出Python时，是否释放全部内存？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flask"><span class="nav-text">Flask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件操作-1"><span class="nav-text">文件操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机网络"><span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-和-udp-的特点"><span class="nav-text">TCP 和 UDP 的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-的三次握手"><span class="nav-text">TCP 的三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-的四次挥手"><span class="nav-text">TCP 的四次挥手</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux"><span class="nav-text">Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常用命令"><span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gbd"><span class="nav-text">gbd</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git"><span class="nav-text">Git</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常用命令-1"><span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#git-pull-时发生冲突"><span class="nav-text">git pull 时发生冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修复bug"><span class="nav-text">修复bug</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#git-merge-和-git-rebase-区别"><span class="nav-text">git merge 和 git rebase 区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reference"><span class="nav-text">Reference</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


        
	  </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SmileLingyong</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="#">
    FreeSky
  </a>(Reserved)

  
  <span id="busuanzi_container_site_uv">
     &nbsp; | &nbsp;  用户量: <span id="busuanzi_value_site_uv"></span>
  </span>
  <span id="busuanzi_container_site_pv">
    &nbsp; | &nbsp;  总访问量: <span id="busuanzi_value_site_pv"></span>
  </span>

  
</div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/others/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/others/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/others/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/others/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/others/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.2" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    var $aboutContent = $('#posts-about');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0 && $aboutContent.length === 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
  
     <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("9QoQXWnRR4zwSFuxRv52kUpi-gzGzoHsz", "zlgcRzgHF7AHu8TKLJUwCAjw");</script>
<script>
function showTime(Counter) {
  var query = new AV.Query(Counter);
  $(".leancloud_visitors").each(function() {
    var url = $(this).attr("id").trim();
    query.equalTo("url", url);
    query.find({
      success: function(results) {
        if (results.length == 0) {
          var content = $(document.getElementById(url)).text() + ': 0';
          $(document.getElementById(url)).text(content);
          return;
        }
        for (var i = 0; i < results.length; i++) {
          var object = results[i];
          var content = $(document.getElementById(url)).text() + ': ' + object.get('time');
          $(document.getElementById(url)).text(content);
        }
      },
      error: function(object, error) {
        console.log("Error: " + error.code + " " + error.message);
      }
    });

  });
}

function addCount(Counter) {
  var Counter = AV.Object.extend("Counter");
  url = $(".leancloud_visitors").attr('id').trim();
  title = $(".leancloud_visitors").attr('data-flag-title').trim();
  var query = new AV.Query(Counter);
  query.equalTo("url", url);
  query.find({
    success: function(results) {
      if (results.length > 0) {
        var counter = results[0];
        counter.fetchWhenSave(true);
        counter.increment("time");
        counter.save(null, {
          success: function(counter) {
            var content = $(document.getElementById(url)).text() + ': ' + counter.get('time');
            $(document.getElementById(url)).text(content);
          },
          error: function(counter, error) {
            console.log('Failed to save Visitor num, with error message: ' + error.message);
          }
        });
      } else {
        var newcounter = new Counter();
        newcounter.set("title", title);
        newcounter.set("url", url);
        newcounter.set("time", 1);
        newcounter.save(null, {
          success: function(newcounter) {
              console.log("newcounter.get('time')="+newcounter.get('time'));
            var content = $(document.getElementById(url)).text() + ': ' + newcounter.get('time');
            $(document.getElementById(url)).text(content);
          },
          error: function(newcounter, error) {
            console.log('Failed to create');
          }
        });
      }
    },
    error: function(error) {
      console.log('Error:' + error.code + " " + error.message);
    }
  });
}
$(function() {
  var Counter = AV.Object.extend("Counter");
  if ($('.leancloud_visitors').length == 1) {
    addCount(Counter);
  } else if ($('.post-title-link').length > 1) {
    showTime(Counter);
  }
}); 
</script>
  
</body>
</html>
